#!/usr/bin/perl -w
# see usage string below

use strict 'subs';

sub usage {
  print(<<"EOF");
usage: $0 [-o outname] file.tok [extension.tok [...]]

This script processes a master token description and produces several files:
  - a .ml file with token flags
  - a .cc file with a table of spellings, and table of flags
  - a .ids file with grammar token names, ids, and aliases

The filenames are named with the same base as the input .tok file,
or with whatever base is specified with the -o option.
EOF
}

$baseName = "";
$myCommand = "$0 " . join(' ', @ARGV);

while (@ARGV != 0 && $ARGV[0] =~ m/^-/) {
  my $arg = $ARGV[0];
  shift @ARGV;
  if ($arg eq "-o") {
    $baseName = $ARGV[0];
    shift @ARGV;
  }
  else {
    print("unknown option: $arg\n");
    usage();
    exit(2);
  }
}

if (@ARGV < 1) {
  usage();
  exit(0);
}

$fname = $ARGV[0];

if (!$baseName) {
  $baseName = $fname;
  $baseName =~ s|\.[^.]*$||;    # strip extension
}

# write the preambles

$latch = "$baseName.ml";
$latch =~ tr|a-z./|A-Z__|;
my $toks = <<"EOF";
(* $baseName.ml
 * do not edit; this file automatically generated by
 *   $myCommand
 *)

open CcTokens

(* token flags *)
type token_flag =
  | TF_MULTISPELL     (* token has multiple spellings *)
  | TF_NONSEPARATOR   (* token is a nonseparator *)
  | TF_CPLUSPLUS      (* token is a keyword in C++, but an identifier in C *)

let token_flags = function
EOF


my $ids = <<"EOF";
// $baseName.ids
// do not edit; this file automatically generated by
//   $myCommand

// form:
//   <code> : <name> [<alias>] ;

EOF


# process the input file(s), effectively a concatenation of all the
# files supplied on the command line
$nextId = 0;
while (@ARGV > 0) {
  $fname = $ARGV[0];
  $lineNum = 0;
  shift @ARGV;

  # open the input file
  open(my $IN, "<$fname") or die("cannot open $fname: $!\n");

  # process it
  while (defined($line = <$IN>)) {
    $lineNum++;

    # blank lines and comment lines are copied to the output verbatim,
    # once we've seen the first line which is neither
    if ($line =~ m|^\s*$| or
        $line =~ m|^\s*//|) {
      if (0 and $nextId) {
        # indent unindented comments
        if ($line =~ m|^//|) {
          $line = "  " . $line;
        }

        $toks .= $line;
        $ids .= $line;
      }
      next;
    }

    # parse the line
    chomp($line);
    my ($enumerator, $spelling, $flags) =
      ($line =~ m|^\s*([a-zA-Z_0-9]+),\s*(\"[^\"]*\")\s*,\s*:(.*)$|);

    #print("enumerator: $enumerator\n");
    #print("spelling:   $spelling\n");
    #print("flags:      $flags\n");
    #exit(0);

    if (!defined($flags)) {
      die("$fname:$lineNum: malformed line\n");
    }

    # parse the flags
    $multiSpell = ($flags =~ m|m|);
    $nonsep = ($flags =~ m|n|);
    $cpp = ($flags =~ m|p|);

    my @f;
    if ($multiSpell) { push @f, "TF_MULTISPELL"; }
    if ($nonsep)     { push @f, "TF_NONSEPARATOR"; }
    if ($cpp)        { push @f, "TF_CPLUSPLUS"; }

    # emit to each file
    if ($multiSpell) {
       $toks .= "  | $enumerator s -> [" . (join "; ", @f) . "]\n";
    } else {
       $toks .= "  | $enumerator -> [" . (join "; ", @f) . "]\n";
    }

    $ids .= sprintf "  %3d : %-30s %s;\n",
       $nextId,
       $enumerator,
       ($multiSpell ? "" : $spelling);

    $nextId++;
  }
}


# open the output files
open my $ML, ">$baseName.ml"
   or die "cannot open $baseName.ml: $!";
open my $IDS, ">$baseName.ids"
   or die "cannot open $baseName.ids: $!\n";

print $ML $toks;
print $IDS $ids;
