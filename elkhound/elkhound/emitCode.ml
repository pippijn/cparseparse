open Camlp4.PreCast
open GrammarType

module OCamlPrinter = Printers.OCaml
let (|>) = BatPervasives.(|>)

(************************************************
 * :: Output helpers
 ************************************************)

let _loc = Loc.ghost

let output_newline out =
  output_char out '\n'

let output_endline out line =
  output_string out line;
  output_newline out

let output_int out i =
  output_string out (string_of_int i)


let closing f x channels =
  let r =
    try
      f x
    with e ->
      List.iter close_out channels;
      raise e
  in
  List.iter close_out channels;
  r


(************************************************
 * :: Identifier checkers
 ************************************************)


let is_lid id =
  assert (id <> "");
  match id.[0] with
  | 'a' .. 'z' | '_' -> true
  | _ -> false

let is_uid id =
  assert (id <> "");
  match id.[0] with
  | 'A' .. 'Z' -> true
  | _ -> false


(************************************************
 * :: Semantic type helpers
 ************************************************)


let semtype sym =
  match sym.semtype with
  | None ->
      <:ctyp<'$lid:"t" ^ sym.name$>>
  | Some semtype ->
      semtype


let final_semtype final_prod =
  match final_prod.right with
  | Nonterminal (_, { nbase = { semtype } }) :: _ ->
      begin match semtype with
      | None ->
          failwith "final nonterminal needs defined type"
      | Some <:ctyp<'$_$>> ->
          failwith "final nonterminal cannot be polymorphic"
      | Some semtype ->
          semtype
      end

  | _ ->
      failwith "could not find final nonterminal"


(************************************************
 * :: Common output functions
 ************************************************)


let make_ml_prologue out =
  (* prologue *)
  output_endline out "(* *** DO NOT EDIT BY HAND *** *)";
  output_endline out "(* automatically generated by parsgen *)";
  output_newline out


let fold_bindings =
  List.fold_left (fun code binding ->
    <:expr<let $binding$ in $code$>>
  )

(************************************************
 * :: Tokens
 ************************************************)


let make_ml_token_type terms =
  Array.map (fun term ->
    let semtype =
      assert (is_uid term.tbase.name);
      <:ctyp<$uid:term.tbase.name$>>
    in

    match term.tbase.semtype with
    | None    -> semtype
    | Some ty -> <:ctyp<$semtype$ of $ty$>>
  ) terms
  |> Array.to_list
  |> Ast.tyOr_of_list



let make_ml_token_fn ?default value terms =
  let cases =
    Array.fold_left (fun cases term ->
      try
        let name = term.tbase.name in
        assert (is_uid name);

        let patt =
          match term.tbase.semtype with
          | None   -> <:patt<$uid:name$>>
          | Some _ -> <:patt<$uid:name$ sval>>
        in

        let case =
          <:match_case<$patt$ -> $value term$>>
        in

        <:match_case<$cases$ | $case$>>
      with Exit ->
        cases
    ) <:match_case<>> terms
  in

  let cases =
    match default with
    | None -> cases
    | Some case -> <:match_case<$cases$ | $case$>>
  in

  <:expr<function $cases$>>


let make_ml_tokens terms =
  (* emit token type declaration in both mli and ml *)
  let types = make_ml_token_type terms in
  let intf =
    <:sig_item<
      type t = $types$
      include Lexerint.TokenInfo with type t := t
    >>
  in

  (* emit the token functions *)
  let name_fn =
    make_ml_token_fn (fun term ->
      <:expr<$str:term.tbase.name$>>
    ) terms
  in

  let desc_fn =
    make_ml_token_fn (fun { alias; tbase = { name } } ->
      match alias with
      | ""    -> <:expr<$str:name$>>
      | alias -> <:expr<$str:alias$>>
    ) terms
  in

  let index_fn =
    make_ml_token_fn (fun term ->
      <:expr<$int:string_of_int term.term_index$>>
    ) terms
  in

  let sval_fn =
    make_ml_token_fn (fun term ->
      match term.tbase.semtype with
      | None   -> raise Exit
      | Some _ -> <:expr<SemanticValue.repr sval>>
    ) terms ~default:<:match_case<tok -> SemanticValue.null>>
  in

  let impl =
    <:str_item<
      type t = $types$
      let name = $name_fn$
      let desc = $desc_fn$
      let index = $index_fn$
      let sval = $sval_fn$
    >>
  in

  intf, impl


(************************************************
 * :: Concrete syntax tree
 ************************************************)

let ctyp_of_nonterminal nonterm =
  (* the type is the referenced nonterminal module *)
  let typ = nonterm.nbase.name in
  assert (is_uid typ);
  <:ctyp<$uid:typ$.t>>


let ctyp_of_terminal term =
  (* use the terminal type *)
  match term.tbase.semtype with
  | None ->
      failwith "tagged terminals must have a declared type"
  | Some ty ->
      ty


let ctyp_of_symbol = function
  | Nonterminal (_, nonterm) -> ctyp_of_nonterminal nonterm
  | Terminal    (_,    term) -> ctyp_of_terminal term


(* XXX: if this function changes its output, PtreeMaker.prods probably
 * also needs to change *)
let production_types has_merge prods =
  let merge_types =
    if has_merge then
      [ <:ctyp<Merge of t * t>> ]
    else
      []
  in

  match prods with
  (* nonterminal with a single production that is a tagged terminal *)
  | [{ right = [Terminal (tag, term)] }] when tag <> "" ->
      assert (not has_merge);
      let semtype = ctyp_of_terminal term in
      let ty_dcl = Ast.TyDcl (_loc, "t", [], semtype, []) in

      Ast.SgTyp (_loc, ty_dcl),
      Ast.StTyp (_loc, ty_dcl)

  | prods ->
      let types =
        List.map (fun prod ->
          if false then (
            print_string "    (*";
            PrintGrammar.print_production prod;
            print_endline " *)";
          );

          let prod_type =
            List.map (fun sym ->
              match sym with
              | Nonterminal ("", _)
              | Terminal ("", _) ->
                  (* nothing to do for untagged symbols *)
                  []

              | sym ->
                  [ctyp_of_symbol sym]

            ) prod.right |> List.concat |> Ast.tyAnd_of_list
          in

          let prod_name =
            match prod.prod_name with
            | None      -> "P" ^ string_of_int prod.prod_index
            | Some name -> assert (is_uid name); name
          in

          let prod_variant =
            match prod_type with
            | <:ctyp<>> -> <:ctyp<$uid:prod_name$>>
            | _	      -> <:ctyp<$uid:prod_name$ of $prod_type$>>
          in

          <:ctyp<$prod_variant$>>
        ) prods
      in

      let types = Ast.tyOr_of_list (merge_types @ types) in

      (* TODO: with sexp *)
      <:sig_item<type t = $types$>>,
      <:str_item<type t = $types$ | SEXP>>



let make_ml_parse_tree prods_by_lhs =
  let bindings =
    List.rev (Array.fold_left (fun bindings prods ->
      match prods with
      | [] ->
          (* the empty nonterminal has no productions *)
          bindings

      | { left = { nbase = { name } } } :: _ when name.[0] = '_' ->
          (* we do not emit code for the synthesised start rule *)
          bindings

      | first :: _ ->
          let nonterm = first.left in
          let name = nonterm.nbase.name in
          assert (is_uid name);

          let has_merge = nonterm.merge != None in

          let intf_types, impl_types = production_types has_merge prods in

          (* signature *)
          let intf =
            <:module_type<
              sig
                $intf_types$
                val sexp_of_t : t -> Sexplib.Sexp.t
                val t_of_sexp : Sexplib.Sexp.t -> t
              end
            >>
          in

          (* implementation *)
          let impl =
            <:module_expr<
              struct
                $impl_types$
              end
            >>
          in

          let binding =
            <:module_binding<$name$ : $intf$ = $impl$>>
          in

          binding :: bindings
    ) [] prods_by_lhs)
  in

  let combined =
    BatList.reduce (fun combined binding ->
      Ast.MbAnd (_loc, binding, combined)
    ) (List.rev bindings)
  in

  let first_module =
    match bindings with
    | <:module_binding<$name$ : $_$ = $_$>> :: _ ->
        name
    | _ ->
        failwith "could not find first module"
  in

  let modules = Ast.StRecMod (_loc, combined) in

  let impl =
    <:str_item<
      open Sexplib.Conv

      $modules$

      type t = $uid:first_module$.t
      let t_of_sexp = $uid:first_module$.t_of_sexp
      let sexp_of_t = $uid:first_module$.sexp_of_t
    >>
  in

  impl


(************************************************
 * :: User actions
 ************************************************)


(* ------------------- description functions ------------------ *)
let make_ml_descriptions terms nonterms =
  (* emit a map of terminal ids to their names *)
  let term_names_array =
    let names =
      Array.map (fun term -> <:expr<$str:term.tbase.name$>>) terms
      |> Array.to_list
      |> Ast.exSem_of_list
    in
    <:str_item<let termNamesArray : string array = [| $names$ |]>>
  in

  (* emit a map of nonterminal ids to their names *)
  let nonterm_names_array =
    let names =
      Array.map (fun nonterm -> <:expr<$str:nonterm.nbase.name$>>) nonterms
      |> Array.to_list
      |> Ast.exSem_of_list
    in
    <:str_item<let nontermNamesArray : string array = [| $names$ |]>>
  in

  <:str_item<
    $term_names_array$
    $nonterm_names_array$
  >>


(* ------------------- actions ------------------ *)
let make_ml_actions prods =
  (* iterate over productions, emitting action function closures *)
  let closures =
    Array.map (fun prod ->
      (* put the production in comments above the defn *)
      if false then (
        print_string "(*";
        PrintGrammar.print_production prod;
        print_endline " *)";
      );

      let make_binding tag index sym =
        assert (is_lid tag);
        <:binding<$lid:tag$ = (SemanticValue.obj svals.($int:string_of_int index$) : $semtype sym$)>>
      in

      (* iterate over RHS elements, emitting bindings for each with a tag *)
      let bindings =
        BatList.mapi (fun index sym ->
          match sym with
          | Terminal ("", _)
          | Nonterminal ("", _) ->
              (* only consider elements with a tag *)
              []

          | Terminal (tag, term) ->
              [make_binding tag index term.tbase]

          | Nonterminal (tag, nonterm) ->
              [make_binding tag index nonterm.nbase]
        ) prod.right |> List.concat
      in

      let action_code =
        match prod.action with
        | None ->
            begin match bindings with
            | [ <:binding<$lid:first_tagged$ = $_$>> ] ->
                <:expr<$lid:first_tagged$>>

            | [binding] ->
                failwith "invalid name binding format"

            | binding :: _ ->
                (*PrintGrammar.print_production prod;*)
                (* TODO: move this to a semantic check phase *)
                failwith "production with more than one binding must provide action code"

            | [] ->
                (*PrintGrammar.print_production prod;*)
                (* TODO: this, too *)
                failwith "no name bindings in production with default action"
            end
        | Some code ->
            code
      in

      (* give a name to the yielded value so we can ensure it conforms to
       * the declared type *)
      let result =
        <:expr<
          (* now insert the user's code, to execute in this environment of
           * properly-typed semantic values *)
          let __result : $semtype prod.left.nbase$ = $action_code$ in
          (* cast to SemanticValue.t *)
          SemanticValue.repr __result
        >>
      in

      let fun_body = fold_bindings result bindings in
      
      <:expr<fun svals -> $fun_body$>>
    ) prods

    |> Array.to_list
    |> Ast.exSem_of_list
  in

  <:rec_binding<reductionActionArray = [| $closures$ |]>>


let make_ml_spec_func name semtype rettype kind func id =
  match func with
  | None ->
      <:expr<$lid:"default_" ^ name$ $lid:kind ^ "NamesArray"$ ($int:string_of_int id$)>>

  | Some { params; code } ->
      let real_rettype =
        if rettype = semtype then
          <:ctyp<SemanticValue.t>>
        else
          rettype
      in

      let untyped_params =
        List.rev_map (fun param ->
          <:patt<($lid:"_" ^ param$ : SemanticValue.t)>>
        ) params
      in

      let bindings =
        <:binding<__result : $rettype$ = $code$>>
        :: List.rev_map (fun param ->
          <:binding<($lid:param$ : $semtype$) = SemanticValue.obj $lid:"_" ^ param$>>
        ) params
      in

      let result =
        if real_rettype != rettype then
          <:expr<SemanticValue.repr __result>>
        else
          <:expr<__result>>
      in

      let fun_body = fold_bindings result bindings in

      List.fold_left (fun code param ->
        <:expr<fun $param$ -> $code$>>
      ) fun_body untyped_params


let make_ml_dup_del_merge terms nonterms =

  let make sf_name a_name rettype kind base func syms =
    let closures =
      Array.mapi (fun i sym ->
        let paramtype = semtype (base sym) in
        let rettype = BatOption.default paramtype rettype in
        make_ml_spec_func sf_name paramtype rettype kind (func sym) i
      ) syms

      |> Array.to_list
      |> Ast.exSem_of_list
    in

    assert (is_lid a_name);
    <:rec_binding<$lid:a_name ^ "Array"$ = [| $closures$ |]>>
  in

  let make_nonterm sf_name a_name func rettype =
    make sf_name a_name rettype
      "nonterm"
      (fun nonterm -> nonterm.nbase)
      func
      nonterms
  in

  let make_term sf_name a_name func rettype =
    make sf_name a_name rettype
      "term"
      (fun term -> term.tbase)
      func
      terms
  in

  [
    (* ------------------- dup/del/merge/keep nonterminals ------------------ *)
    make_nonterm "dup"   "duplicateNontermValue"  (fun nonterm -> nonterm.nbase.dup) None;
    make_nonterm "del"   "deallocateNontermValue" (fun nonterm -> nonterm.nbase.del) (Some <:ctyp<unit>>);
    make_nonterm "merge" "mergeAlternativeParses" (fun nonterm -> nonterm.merge) 	   None;
    make_nonterm "keep"  "keepNontermValue"       (fun nonterm -> nonterm.keep) 	   (Some <:ctyp<bool>>);

    (* ------------------- dup/del/classify terminals ------------------ *)
    make_term "dup"      "duplicateTerminalValue"  (fun term -> term.tbase.dup) None;
    make_term "del"      "deallocateTerminalValue" (fun term -> term.tbase.del) (Some <:ctyp<unit>>);
    make_term "classify" "reclassifyToken"         (fun term -> term.classify)  (Some <:ctyp<int>>);
  ]


let make_ml_action_code terms nonterms prods final_prod verbatims impl_verbatims =
  let result_type = final_semtype (final_prod prods) in

  let closures =
    make_ml_actions prods
    :: make_ml_dup_del_merge terms nonterms
    |> Ast.rbSem_of_list
  in

  <:sig_item<
    (* insert the stand-alone verbatim sections *)
    $Ast.sgSem_of_list verbatims$

    (* all that goes into the interface is the name of the
     * UserActions.t object *)
    val userActions : $result_type$ UserActions.t
  >>,
  <:str_item<
    (* Open module so record field labels are visible *)
    open UserActions

    (* impl_verbatim sections *)
    $Ast.stSem_of_list impl_verbatims$

    $make_ml_descriptions terms nonterms$

    let userFunctions : UserActions.functions = { $closures$ }

    (* main action function; uses the array emitted above *)
    let reductionAction (productionId : int) (svals : SemanticValue.t array) : SemanticValue.t =
      userFunctions.reductionActionArray.(productionId) svals

    (* dup *)
    let duplicateNontermValue (nontermId : int) (sval : SemanticValue.t) : SemanticValue.t =
      userFunctions.duplicateNontermValueArray.(nontermId) sval
    let duplicateTerminalValue (termId : int) (sval : SemanticValue.t) : SemanticValue.t =
      userFunctions.duplicateTerminalValueArray.(termId) sval
    (* del *)
    let deallocateNontermValue (nontermId : int) (sval : SemanticValue.t) : unit =
      userFunctions.deallocateNontermValueArray.(nontermId) sval
    let deallocateTerminalValue (termId : int) (sval : SemanticValue.t) : unit =
      userFunctions.deallocateTerminalValueArray.(termId) sval
    (* merge *)
    let mergeAlternativeParses (nontermId : int) (left : SemanticValue.t) (right : SemanticValue.t) : SemanticValue.t =
      userFunctions.mergeAlternativeParsesArray.(nontermId) left right
    (* keep *)
    let keepNontermValue (nontermId : int) (sval : SemanticValue.t) : bool =
      userFunctions.keepNontermValueArray.(nontermId) sval
    (* classify *)
    let reclassifyToken (oldTokenType : int) (sval : SemanticValue.t) : int =
      userFunctions.reclassifyTokenArray.(oldTokenType) sval
    (* emit a function to describe terminals; at some point I'd like to
     * extend my grammar format to allow the user to supply
     * token-specific description functions, but for now I will just
     * use the information easily available to synthesise one;
     * I print "sval % 100000" so I get a 5-digit number, which is
     * easy for me to compare for equality without adding much clutter
     *
     * ML: I could do something like this using Obj, but I'd rather
     * not abuse that interface unnecessarily. *)
    let terminalDescription (termId : int) (sval : SemanticValue.t) : string =
      termNamesArray.(termId)
    (* and a function to describe nonterminals also *)
    let nonterminalDescription (nontermId : int) (sval : SemanticValue.t) : string =
      nontermNamesArray.(nontermId)
    (* emit functions to get access to the static maps *)
    let terminalName (termId : int) : string =
      termNamesArray.(termId)
    let nonterminalName (nontermId : int) : string =
      nontermNamesArray.(nontermId)

    (* wrap all the action stuff up as a record *)
    let userActions : $result_type$ UserActions.t = {
      reductionAction;
      duplicateTerminalValue;
      duplicateNontermValue;
      deallocateTerminalValue;
      deallocateNontermValue;
      mergeAlternativeParses;
      keepNontermValue;
      reclassifyToken;
      terminalDescription;
      nonterminalDescription;
      terminalName;
      nonterminalName;
    }
  >>


(************************************************
 * :: Parse tables
 ************************************************)

let exSem_of_int_list table =
  Array.map (fun value ->
    <:expr<$int:string_of_int value$>>
  ) table
  |> Array.to_list
  |> Ast.exSem_of_list


let print_tables tables =
  let open ParseTablesType in

  <:str_item<
    let parseTables = ParseTablesType.({
      numTerms = $int:string_of_int tables.numTerms$;
      numNonterms = $int:string_of_int tables.numNonterms$;
      numProds = $int:string_of_int tables.numProds$;

      numStates = $int:string_of_int tables.numStates$;

      actionCols = $int:string_of_int tables.actionCols$;
      actionTable = [| $exSem_of_int_list tables.actionTable$ |];

      gotoCols = $int:string_of_int tables.gotoCols$;
      gotoTable = [| $exSem_of_int_list tables.gotoTable$ |];

      prodInfo_rhsLen = [| $exSem_of_int_list tables.prodInfo_rhsLen$ |];
      prodInfo_lhsIndex = [| $exSem_of_int_list tables.prodInfo_lhsIndex$ |];

      stateSymbol = [| $exSem_of_int_list tables.stateSymbol$ |];

      ambigTable = [| $exSem_of_int_list tables.ambigTable$ |];

      nontermOrder = [| $exSem_of_int_list tables.nontermOrder$ |];

      startState = $int:string_of_int tables.startState$;
      finalProductionIndex = $int:string_of_int tables.finalProductionIndex$;
    })
  >>

let make_ml_tables dat tables =
  Marshal.to_channel dat tables [Marshal.No_sharing];

  <:sig_item<
    val parseTables : ParseTablesType.t
  >>,
  if Config.use_table_dump then (
    Some <:str_item<
      let parseTables : ParseTablesType.t =
        input_value (open_in_bin "_build/ccparse/gr/ccTables.dat")
    >>
  ) else (
    if true then
      None
    else
      Some (print_tables tables)
  )


(************************************************
 * :: Toplevel code generators/printers
 ************************************************)


let emit_tokens name terms =
  (* Tokens *)
  let dcl = name ^ "Tokens.mli" in
  let out = name ^ "Tokens.ml" in
  let intf, impl = make_ml_tokens terms in

  OCamlPrinter.print_interf ~output_file:dcl intf;
  OCamlPrinter.print_implem ~output_file:out impl


let emit_parse_tree name prods_by_lhs =
  (* Parse Tree *)
  let out = name ^ "Ptree.ml" in
  let impl = make_ml_parse_tree prods_by_lhs in

  OCamlPrinter.print_implem ~output_file:out impl;
  (* TODO: with sexp *)
  ignore (Sys.command ("sed -i -e 's/type t = string;;/type t = string with sexp;;/' " ^ out));
  ignore (Sys.command ("sed -i -e 's/ | SEXP;;/ with sexp;;/' " ^ out))


let emit_user_actions name terms nonterms prods final_prod verbatims impl_verbatims =
  (* Actions *)
  let dcl = name ^ "Actions.mli" in
  let out = name ^ "Actions.ml" in
  let intf, impl =
    make_ml_action_code
      terms
      nonterms
      prods
      final_prod verbatims impl_verbatims
  in

  OCamlPrinter.print_interf ~output_file:dcl intf;
  OCamlPrinter.print_implem ~output_file:out impl


let emit_ptree_actions name terms nonterms prods final_prod verbatims impl_verbatims =
  (* Parse Tree Actions *)
  emit_user_actions
      (name ^ "Ptree")
      terms
      (PtreeMaker.nonterms nonterms)
      (PtreeMaker.prods prods)
      final_prod verbatims impl_verbatims


let emit_tables name tables =
  (* Tables *)
  let dcl = name ^ "Tables.mli" in
  let out = name ^ "Tables.ml" in
  let dat = open_out_bin (name ^ "Tables.dat") in

  let intf, impl =
    closing (make_ml_tables dat) tables
      [dat]
  in

  OCamlPrinter.print_interf ~output_file:dcl intf;

  match impl with
  | None ->
      let out = open_out out in
      closing (TablePrinting.print_tables out) tables
        [out]

  | Some impl ->
      OCamlPrinter.print_implem ~output_file:out impl


(************************************************
 * :: Main entry point
 ************************************************)

let emit_ml name terms nonterms prods prods_by_lhs verbatims impl_verbatims tables =
  let final_prod prods = prods.(tables.ParseTablesType.finalProductionIndex) in

  emit_tokens name terms;
  emit_parse_tree name prods_by_lhs;
  emit_user_actions name terms nonterms prods final_prod verbatims impl_verbatims;
  emit_ptree_actions name terms nonterms prods final_prod verbatims impl_verbatims;
  emit_tables name tables
