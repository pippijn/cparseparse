(* grammar for C++
 * see license.txt for copyright and terms of use
 *
 * A word of warning: there are three sources of names running
 * around here:
 *   (1) the c++ standard's grammar's names
 *   (2) my modified grammar's names
 *   (3) names of AST nodes
 * (1) and (2) correspond everywhere except in places where I want
 * the grammar to do more parsing work than the standard's (mainly
 * for declarators) and where I've chosen to fold in "opt".  The
 * names in (3) are often different because later phases of analysis
 * want to see different conceptual structure.	Anyway, the point is
 * to be aware of which kind of name a given thing is.
 *
 *
 * Note about destructive actions: because semantic values can be
 * yielded to more than one reduction action (a phenomenon I call
 * "multi-yield"), actions which modify one of their subtree semantic
 * values are dangerous, because you can have actions from one
 * interpretation interfering with actions from another
 * interpretation.
 *
 * Therefore, to the extent reasonable, I avoid destructive actions.
 *
 * However there are a few places where I want destructive actions
 * anyway, and there are two broad strategies employed for managing
 * them:
 *
 *   (1) Disable multi-yield for the modified subtrees.  If an action
 *	 modifies subtree nonterminal 'A', then in the definition of
 *	 'A' I say "dup(n) { return NULL; }" to ensure that once the
 *	 value is yielded once, it can't be yielded again.  Thus, if
 *	 in fact it *is* yielded a second time, I'll get a segfault
 *	 which will alert me to the design flaw in my rules.
 *	 (DeclSpecifier is a good example of this.)
 *
 *   (2) Design the actions to that multiple modifications are
 *	 checked for bad interactions.	In this grammar that is what
 *	 I do for FakeLists, where I either (a) prevent putting a
 *	 node at the head of two lists, or else (b) make sure that
 *	 the two lists are in fact the same list both times.  For
 *	 potentially-ambiguous nodes with FakeList links (Expression
 *	 and Declarator), additional measures are taken to ensure
 *	 the consistency of interaction with the ambiguity links.
 *	 (See Expression::addAmbiguity and Expression::setNext in
 *	 cc_ast_aux.cc.)
 *
 * Every place there's a destructive modification which isn't handled
 * by FakeLists is marked by the phrase 'destructive action'.
 *
 * There is also 'semi-destructive action', which tags places where
 * an action is destructive, but other safeguards are place to ensure
 * that later mutations all have the same effect as the original.
 *)


(* expected statistics *)
option shift_reduce_conflicts 49;
option reduce_reduce_conflicts 73;
option unreachable_nonterminals 1;
option unreachable_terminals 8;


terminals {
  (* grab token list *)
  include("src/ccparse/tok/cc_tokens.ids")

  (* all literals are yielded as their syntax strings *)
  token(string) TOK_INT_LITERAL;
  token(string) TOK_FLOAT_LITERAL;
  token(string) TOK_CHAR_LITERAL;
  token(string) TOK_STRING_LITERAL;

  (* similar for identifiers *)
  token(string) TOK_NAME;
  token(string) TOK_TYPE_NAME;
  token(string) TOK_VARIABLE_NAME;

  (* and annotations *)
  token(string) TOK_ANNOTATION;

  precedence {
    (* high precedence *)
    prec	200 TOK_PREFER_REDUCE;
    right	195 "::";		(* 2005-08-14: see doc/coloncolon.txt *)
    prec	190 "const" "volatile" "else" "[";

    (* neither of these two lines are used, because the grammar
     * encodes their prec/assoc already; however, I have them here as
     * reference, and because these precedence numbers are used by
     * bpprint
     *)
    (*left	140 "()" "[]" "->" "." "++"(postfix) "--"(postfix); *)
    (*right	130 "!" "~" "++"(prefix) "--"(prefix) "-" "+" "*" "&" "(cast)" "sizeof";*)

    left	120 ".*" "->*";		(* 7/07/03: changed from "right".. why was it that way? *)
    left	110 "*" "/" "%";
    left	100 "+" "-";
    left	 90 "<<" ">>";

    (* part of the solution to the angle bracket problem requires
     * dropping these precedence specs and implementing them in the
     * grammar instead *)
    (*left	 80 "<" ">" "<=" ">="; *)

    left	 70 "==" "!=";
    left	 60 "&";
    left	 50 "^";
    left	 40 "|";
    left	 30 "&&";
    left	 20 "||";

    (* also provided only for reference and for bpprint *)
    (*right	 10 "?:"; *)
    (*right	  9 "=" ... "+"; *)
    (* level 8 is the "," of a function argument list *)
    (*left	  7 ","; *)

    prec	  1 TOK_PREFER_SHIFT;
    (* low precedence *)
  }
}


impl_verbatim {
  open Ccabs
  open Ast
  let cancel = GlrEngine.cancel
  let unimplemented s = failwith ("unimplemented " ^ string_of_int s)

  let ambiguous s to_sexp l r =
    print_endline ";-- unhandled ambiguity between --";
    Sexplib.Sexp.output_hum stdout (to_sexp l);
    print_endline "\n;-- and --";
    Sexplib.Sexp.output_hum stdout (to_sexp r);
    print_endline "\n;-- aborting parse --";
    unimplemented s
}


nonterm(Ccabs.Ast.translation_unit) File {
  -> t:TranslationUnit { t }
}


(* ------------- identifiers ------------------- *)
(* simple string of characters *)
nonterm Identifier {
  -> n:TOK_NAME;
}

(* another name that comes up in a few places; it's supposed
 * to refer to a type, but the typechecker will have to enforce
 * that later
 *
 * update: I've substituted it into the grammar elsewhere, since
 * it's just causing s/r conflicts with no gain
 *)
nonterm TypeName {
  -> n:TOK_TYPE_NAME;
}


(* ---------------- higher-level syntax ----------------- *)
(* the section labels that follow (like "A.3") are from the
 * C++ standard document *)

(* ------ A.3 Basic Concepts ------ *)
nonterm TranslationUnit {
  fun dup(n) { unimplemented 1234 }	(* prevent multi-yield *)

  -> empty					{ [] }
  -> xs:TranslationUnit x:Declaration		{ x :: xs }
}

(* ------ A.4 Expressions ------ *)
nonterm PrimaryExpression {
  -> e:Literal
	[Literal];

  -> "this"
	[This] { E_this }

  -> "(" e:Expression ")"
	[Grouping] { E_grouping (e) }

  -> e:IdExpression
	[Variable] { E_variable (e) }
}

nonterm Literal {
  -> i:TOK_INT_LITERAL		[Int]		{ E_intLit i }
  -> f:TOK_FLOAT_LITERAL	[Float]		{ E_floatLit f }
  -> s:StringLiteral		[String]	{ E_stringLit s }
  -> c:TOK_CHAR_LITERAL		[Char]		{ E_charLit c }
  -> "true"			[True]		{ E_boolLit true }
  -> "false"			[False]		{ E_boolLit false }
}

(* a single quoted sequence of characters; this nonterminal exists
 * so that gnu.gr can extend it *)
nonterm PreprocString {
  -> s:TOK_STRING_LITERAL			[String]	{ s }
}

(* a string literal, with all concatenated parts *)
nonterm StringLiteral {
  -> x:PreprocString				{ [x] }
  -> xs:StringLiteral x:PreprocString		{ x :: xs }
}


(* possibly-qualified name *)
nonterm IdExpression {
  fun merge(l,r) { unimplemented 18 }

  -> id:PQualifiedId
	[Id];

  (* a bare "::" qualifier can only appear at the start of a qualifier
   * sequence; I'm enforcing it a little bit differently than the std
   * does *)
  -> "::" id:PQualifiedId
	[GlobalId] { PQ_qualifier ((*~qualifier*)None, (*~targs*)[], id) }
}

(* names that are not qualified *)
nonterm UnqualifiedId {
  fun merge(l,r) { unimplemented 21 }

  -> id:Identifier			[Name]		{ PQ_name (id) }
  -> on:OperatorFunctionId		[Operator]	{ PQ_operator (on) }
  -> on:ConversionFunctionId		[Conversion]	{ PQ_operator (on) }

  (* std has `"~" ClassName' here, but I've chosen to separate out the
   * places that a destructor name can occur, since it avoids an
   * ambiguity with the "~" unary operator *)

  -> id:TemplateId			[Template];
}

(* optional qualifier sequence (with no bare "::"), then an
 * UnqualifiedId; there is no option here that uses "~", since that
 * is handled by PQDtorName *)
nonterm PQualifiedId {
  fun merge(l,r) { unimplemented 26 }

  -> id:UnqualifiedId			precedence("::")
	[Unqual];

  -> n:Identifier "::" id:PQualifiedId
	[Qual] { PQ_qualifier (Some n, (*~targs*)[], id)  }

  (* passing a dependent template as template template argument *)
  -> n:Identifier "::" "template" tn:Identifier
	[TemplateQualNoInst] { unimplemented 30 }

  (* quarl 2006-06-14
   *	changed targs:TemplateArgumentList to targs:TemplateArgumentListOpt;
   *	see in/k0112.cc *)

  -> n:Identifier "<" targs:TemplateArgumentListOpt ">" "::" id:PQualifiedId
	[Template] { PQ_qualifier (Some n, targs, id) }

  (* versions with "template" in front (it's not clear to me that this
   * is equivalent to the standard grammar.. I'm hacking it for now);
   * I just ignore the keyword (is that right?)
   * NOTE: the pattern here is repeated FIVE times!  argh...
   * marking all as TEMPLATE_QUALIFIER_HACK
   *)
  -> "template" n:Identifier "<" targs:TemplateArgumentListOpt ">" "::" id:PQualifiedId
	[TemplateQual] { unimplemented 31 }
}


(* This is a little subtle.  Most of the function calls in a C++
 * source program appear to be ambiguous between E_funCall and
 * E_constructor.  However both of these constructs contain an
 * argument list, and I want the constructed AST nodes to share that
 * list, instead of duplicating it (and only sharing argument
 * subexpressions), for space efficiency reasons.
 *
 * To do that, I insert this nonterminal, which effectively hides the
 * differences in context from the parsing algorithm, so it will be
 * able to share the expression list one level higher than it
 * otherwise would.  (To see the effect, print the node addresses in
 * the resulting ASTs.) *)
nonterm ArgumentList {
  -> "(" e:ExpressionListOpt ")";
}


nonterm PostfixExpression {
  (* ambiguous:
   *   x(y)
   * can either be a function call (x is a function)
   * or a constructor call (x is a type) *)
  fun merge(l,r) { E_ambig (l, r) }

  -> e:PrimaryExpression [PrimaryExpression];

  (* array access *)
  -> a:PostfixExpression "[" e:Expression "]"
	[ArrayAcc] { E_binary (a, BIN_BRACKETS, e) }

  (* fn call *)
  -> f:PostfixExpression a:ArgumentList
	[FunCall] { E_funCall (f, a) }

  (* cppstd has two things with "typename", but I can't find anyplace
   * where their semantics are spelled out.. I have some code from
   * a gcc header which seems to be using them to mean E_constructor,
   * so I will assume that is the right interpretation
   *
   * Note 1: The two "typename" rules are folded into one, with the
   * variation (planned to be) captured down inside 'IdExpression'.
   *
   * Note 2: cppstd uses the grammar to enforce the restriction that
   * "typename" can only be used with a qualified name, whereas I
   * enforce that in the type checker (more informative message). *)
  -> "typename" t:IdExpression a:ArgumentList
	[DepCtorCall] { E_constructor (TS_name ([], t, (*~typenameUsed*)true), a) }

  (* function-style cast, or (equivalently) call to constructor; will
   * almost always be ambiguous with function call, so the distinction
   * will have to be delayed until typechecking *)
  -> spec:CtorExpressionType a:ArgumentList
	[CtorCall] { E_constructor (spec, a) }

  (* field access (includes pseudo-destructor) *)
  -> p:PostfixExpression "." n:MemberName
	[MemberAcc] { E_fieldAcc (p, n) }

  (* deref + field access *)
  -> p:PostfixExpression "->" n:MemberName
	[PtrAcc] { E_arrow (p, n) }

  -> p:PostfixExpression "++"
	[PostInc] { E_effect (EFF_POSTINC, p) }
  -> p:PostfixExpression "--"
	[PostDec] { E_effect (EFF_POSTDEC, p) }

  -> k:CastKeyword "<" t:TypeId ">" "(" e:Expression ")"
	[Cast] { E_keywordCast (k, t, e) }

  -> "typeid" "(" e:Expression ")"
	[TypeidExpr] { E_typeidExpr (e) }
  -> "typeid" "(" t:TypeId ")"
	[TypeidType] { E_typeidType (t) }
}

(* the std calls this SimpleTypeSpecifier, but then also uses that
 * name in some other roles; this is only for the name of a class or
 * type, used as a constructor name *)
nonterm CtorExpressionType {
  (*-> ColonColonOpt NestedNameSpecifier "template" TemplateId; *)

  -> n:PQTypeName		[TypeName]	{ TS_name ([], n, (*~typenameUsed*)false) }
  -> "char"			[Char]		{ TS_simple ([], ST_Char) }
  -> "wchar_t"			[WCharT]	{ TS_simple ([], ST_WCharT) }
  -> "bool"			[Bool]		{ TS_simple ([], ST_Bool) }
  -> "short"			[Short]		{ TS_simple ([], ST_SShort) }
  -> "int"			[Int]		{ TS_simple ([], ST_SInt) }
  -> "long"			[Long]		{ TS_simple ([], ST_SLong) }
  -> "signed"			[Signed]	{ TS_simple ([], ST_SInt) }
  -> "unsigned"			[Unsigned]	{ TS_simple ([], ST_UInt) }
  -> "float"			[Float]		{ TS_simple ([], ST_Float) }
  -> "double"			[Double]	{ TS_simple ([], ST_Double) }
  -> "void"			[Void]		{ TS_simple ([], ST_Void) }
}

nonterm CastKeyword {
  -> "dynamic_cast"		[DynamicCast]		{ unimplemented 58 }
  -> "static_cast"		[StaticCast]		{ unimplemented 59 }
  -> "reinterpret_cast"		[ReinterpretCast]	{ unimplemented 60 }
  -> "const_cast"		[ConstCast]		{ unimplemented 61 }
}

(* here, and everywhere else that FakeList is used, I use right
 * recursion to construct the list; this does mean the stack size
 * is linear in the size of the list, but the benefit of not
 * having to reverse the list or use ASTList (which is difficult
 * to share) is worth it *)
nonterm ExpressionList {
  (* ambiguous; see t0182.cc *)
  fun merge(l,r) { unimplemented 62 }

  -> a:AssignmentExpression
	[Head] { [AE_expr (a)] }
  -> e:ExpressionList "," a:AssignmentExpression
	[Tail] { AE_expr (a) :: e }
}

nonterm ExpressionListOpt {
  -> empty			{ [] }
  -> e:ExpressionList		{ e }
}

(* I am pulling these out since PQVarName can be ~class *)
(*PseudoDestructorName -> "~" ClassName *)
(*PseudoDestructorName -> Qualifier PseudoDestructorName *)

nonterm UnaryExpression {
  (* ambiguous:
   *   sizeof(x)
   * could either be size of an expression 'x', or
   * size of a type called 'x' *)
  fun merge(l,r) { E_ambig (l, r) }

  -> e:PostfixExpression [PostfixExpression];

  -> e:DeleteExpression			[Delete];
  -> e:NewExpression			[New];

  -> "++" e:CastExpression		[PreInc]	{ E_effect (EFF_PREINC, e) }
  -> "--" e:CastExpression		[PreDec]	{ E_effect (EFF_PREDEC, e) }

  (* size of expression *)
  -> "sizeof" e:UnaryExpression		[SizeofExpr]	{ E_sizeofExpr (e) }
  (* size of type *)
  -> "sizeof" "(" t:TypeId ")"		[SizeofType]	{ E_sizeofType (t) }

  (* dereference, addrof *)
  -> "*" e:CastExpression		[Deref]		{ E_deref (e) }
  -> "&" e:CastExpression		[AddrOf]	{ E_addrOf (e) }

  (* other unary operators *)
  -> "+" e:CastExpression		[Plus]		{ E_unary (UNY_PLUS, e) }
  -> "-" e:CastExpression		[Minus]		{ E_unary (UNY_MINUS, e) }
  -> "!" e:CastExpression		[Not]		{ E_unary (UNY_NOT, e) }
  -> "~" e:CastExpression		[BitNot]	{ E_unary (UNY_BITNOT, e) }
}


(* ---------------- "new" and "delete" expressions -------------- *)
nonterm ColonColonOpt {
  -> empty	{ unimplemented 81 }
  -> "::"	{ unimplemented 82 }
}

nonterm NewExpression {
  (* ambiguous (see in/t0482.cc) *)
  fun merge(l,r) { unimplemented 83 }

  -> c:ColonColonOpt "new" p:NewPlacementOpt t:NewTypeId i:NewInitialiserOpt
	{ unimplemented 84 }
  -> c:ColonColonOpt "new" p:NewPlacementOpt "(" t:TypeId ")" i:NewInitialiserOpt
	{ unimplemented 85 }
}

nonterm NewPlacementOpt {
  -> empty				{ unimplemented 86 }
  -> "(" lst:ExpressionList ")"		{ unimplemented 87 }
}

nonterm NewTypeId {
  -> spec:TypeSpecifier decl:NewDeclaratorOpt
	{ unimplemented 88 }
}

(* NewDeclaratorOpt is, as a regular expression:
 *   (PrefixDeclarator)*  ("[" Expression "]"  ("[" ConstExpression "]")* )?
 * where PrefixDeclarator is
 *   "*" CVQualifierSeqOpt, or
 *   "&"
 * however, I cannot find any explanation in the spec of whether "&"
 * is in fact allowed (it doesn't make sense to me) so I do not allow
 * it (so I'll see the counterexample syntax if it exists) *)
nonterm NewDeclaratorOpt {
  -> empty
	{ unimplemented 89 }

  (* pointers *)
  -> "*" cv:CVQualifierSeqOpt d:NewDeclaratorOpt
	{ unimplemented 90 }
  -> n:PtrToMemberName "*" cv:CVQualifierSeqOpt d:NewDeclaratorOpt
	{ unimplemented 91 }

  (* commit to at least one "[" ... "]" *)
  -> d:DirectNewDeclarator		{ unimplemented 92 }
}
nonterm DirectNewDeclarator {
  fun keep(x) { unimplemented 1310 }

  -> (*abstract declarator*) "[" sz:Expression "]"
	{ unimplemented 93 }
  -> d:DirectNewDeclarator "[" sz:ConstantExpression "]"
	{ unimplemented 94 }
}

nonterm NewInitialiserOpt {
  -> empty				{ unimplemented 95 }
  -> "(" lst:ExpressionListOpt ")"	{ unimplemented 96 }
}

nonterm DeleteExpression {
  -> c:ColonColonOpt "delete" e:CastExpression
	{ unimplemented 97 }
  -> c:ColonColonOpt "delete" "[" "]" e:CastExpression
	{ unimplemented 98 }
}
(* ------------ end of "new" and "delete" expressions ------------- *)


(* -------------- BEGIN: syntax after "." or "->" ------------------- *)
(* The standard calls this part
 *
 *   template_opt id-expression
 *
 * but there are some more restrictions I want to add, and I need to
 * build my AST in a certain way (bottom-up), so I redesigned this
 * part of the grammar. *)

nonterm MemberName {
  fun merge(l,r) { unimplemented 99 }

  -> n:SpecialMemberName
	[Name];

  (* cannot say ":: ~" *)
  -> "::" n:IdentifierMemberName
	[GlobalName] { PQ_qualifier (None, [], n) }
}

(* can begin with "~" or "template" or Identifier or "operator" *)
nonterm SpecialMemberName {
  fun merge(l,r) { unimplemented 102 }

  -> n:IdentifierMemberName;

  (* final names *)
  -> "template" n:Identifier "<" list:TemplateArgumentListOpt ">"
	{ PQ_template (n, TA_templateUsed :: list) }
  -> "~" n:Identifier
	{ PQ_name ("~" ^ n) }
  -> "~" n:Identifier "<" list:TemplateArgumentListOpt ">"
	{ PQ_template ("~" ^ n, list) }
  -> on:ConversionFunctionId
	{ PQ_operator (on) }

  (* qualifier name *)
  -> "template" n:Identifier "<" list:TemplateArgumentListOpt ">" "::" rest:SpecialMemberName
	{ PQ_qualifier (Some n, TA_templateUsed :: list, rest) }
}

(* can begin with Identifier, "template" or "operator"; this is
 * essentially what follows "::" in cppstd's qualified-id *)
nonterm IdentifierMemberName {
  fun merge(l,r) { unimplemented 109 }

  (* final names *)
  -> n:Identifier "<" list:TemplateArgumentListOpt ">"
	{ PQ_template (n, list) }
  -> n:Identifier
	{ PQ_name (n) }
  -> on:OperatorFunctionId
	{ PQ_operator (on) }

  (* unqualified templatised operator *)
  -> on:OperatorFunctionId "<" list:TemplateArgumentListOpt ">"
	{ unimplemented 113 }
  (* template-qualified templatised operator *)
  -> "template" on:OperatorFunctionId "<" list:TemplateArgumentListOpt ">"
	{ unimplemented 114 }

  (* qualifier names *)
  -> n:Identifier "<" list:TemplateArgumentListOpt ">" "::" rest:SpecialMemberName
	{ PQ_qualifier (Some n, list, rest) }
  -> n:Identifier "::" rest:SpecialMemberName
	{ PQ_qualifier (Some n, [], rest) }
}
(* -------------- END: syntax after "." or "->" ------------------- *)


nonterm CastExpression {
  (* ambiguous:
   *   (x)(y)
   * could either be a call to function 'x' with argument 'y', or
   * it could be a cast to type 'x' of the expression 'y' *)
  fun merge(l,r) { E_ambig (l, r) }

  -> e:UnaryExpression [UnaryExpression];
  -> "(" t:TypeId ")" e:CastExpression
	[Cast] { E_cast (t, e) }
}

(* ---- binary operator expression ---- *)
(* binary exprs with precedence higher than ">" *)
nonterm BinExp_high {
  (* ambiguous:
   *   (x) - (y)
   * could either be the difference of expressions x and y, or
   * it could be negation of expression y, cast to type x *)
  fun merge(l,r) { unimplemented 120 }

  -> e:CastExpression [CastExpression];

  -> left:BinExp_high ".*"  right:BinExp_high	[DotStar]	{ E_binary (left, BIN_DSTAR, right) }
  -> left:BinExp_high "->*" right:BinExp_high	[ArrowStar]	{ E_binary (left, BIN_ASTAR, right) }

  -> left:BinExp_high "*"  right:BinExp_high	[Mul]		{ E_binary (left, BIN_MUL, right) }
  -> left:BinExp_high "/"  right:BinExp_high	[Div]		{ E_binary (left, BIN_DIV, right) }
  -> left:BinExp_high "%"  right:BinExp_high	[Mod]		{ E_binary (left, BIN_MOD, right) }
  -> left:BinExp_high "+"  right:BinExp_high	[Add]		{ E_binary (left, BIN_ADD, right) }
  -> left:BinExp_high "-"  right:BinExp_high	[Sub]		{ E_binary (left, BIN_SUB, right) }
  -> left:BinExp_high "<<" right:BinExp_high	[Lsh]		{ E_binary (left, BIN_LSH, right) }
  -> left:BinExp_high ">>" right:BinExp_high	[Rsh]		{ E_binary (left, BIN_RSH, right) }
}

(* binary exprs with same precedence as ">"
 *
 * The binary expressions are split like this because I removed the
 * precedence from ">", etc.  But now (8/21/03) I'm not sure *why* I
 * had to remove them; couldn't I have just forced the other rules
 * that mention ">" to have no precedence (perhaps by adding syntax to
 * Elkhound to say that)?  Hmm... oh well. *)
nonterm BinExp_mid {
  (* ambiguous:
   *   x<y>(z)
   * could either be two relationals (E_binary), with redundant parens
   * around 'z', or else it could be the construction of a templatised
   * object (E_constructor), depending on whether 'x' names a type *)
  fun merge(l,r) { E_ambig (l, r) }

  -> e:BinExp_high [BinExp_high];

  (* must express associativity directly; since these are all
   * left-associative, we require that there not be any reduced
   * ">" operators in the right context *)
  -> left:BinExp_mid "<"  right:BinExp_high	[Less]		{ E_binary (left, BIN_LESS, right) }
  -> left:BinExp_mid ">"  right:BinExp_high	[Greater]	{ E_binary (left, BIN_GREATER, right) }
  -> left:BinExp_mid "<=" right:BinExp_high	[LessEq]	{ E_binary (left, BIN_LESSEQ, right) }
  -> left:BinExp_mid ">=" right:BinExp_high	[GreaterEq]	{ E_binary (left, BIN_GREATEREQ, right) }
}

(* binary exprs with lower precedence than ">" *)
nonterm BinExp_low {
  (* ambiguous:
   *   (x) & (y)
   * could either be the bitwise AND of expressions x and y, or
   * it could be the address of expression y, cast to type x *)
  fun merge(l,r) { E_ambig (l, r) }

  -> e:BinExp_mid [BinExp_mid];

  -> left:BinExp_low "==" right:BinExp_low	[Equal]		{ E_binary (left, BIN_EQUAL, right) }
  -> left:BinExp_low "!=" right:BinExp_low	[NotEqual]	{ E_binary (left, BIN_NOTEQUAL, right) }
  -> left:BinExp_low "&"  right:BinExp_low	[BitAnd]	{ E_binary (left, BIN_BITAND, right) }
  -> left:BinExp_low "^"  right:BinExp_low	[BitXor]	{ E_binary (left, BIN_BITXOR, right) }
  -> left:BinExp_low "|"  right:BinExp_low	[BitOr]		{ E_binary (left, BIN_BITOR, right) }

  -> left:BinExp_low "&&" right:BinExp_low	[Or]		{ E_binary (left, BIN_OR, right) }
  -> left:BinExp_low "||" right:BinExp_low	[And]		{ E_binary (left, BIN_AND, right) }
}


nonterm BinaryExpression -> e:BinExp_low;


nonterm ConditionalExpression {
  (* in/k0012.cc *)
  fun merge(l,r) { unimplemented 146 }

  -> e:BinaryExpression [BinaryExpression];

  -> cond:BinaryExpression "?" th:Expression ":" el:AssignmentExpression
	[Conditional] { E_cond (cond, th, el) }
}

(* why is conditional not allowed on left side of = ?  can I confirm
 * that in another language spec?  clearly both alternatives would have
 * to be like-typed lvalues, but... *)
nonterm AssignmentExpression {
  fun merge(l,r) { unimplemented 1301 }

  -> e:ConditionalExpression [ConditionalExpression];

  -> e1:BinaryExpression op:AssignmentOperator e2:AssignmentExpression
	[Assign] { E_assign (e1, op, e2) }

  -> e:ThrowExpression [Throw];
}

nonterm AssignmentOperator {
  -> "*="	[MulAssign]	{ BIN_MUL }
  -> "/="	[DivAssign]	{ BIN_DIV }
  -> "%="	[ModAssign]	{ BIN_MOD }
  -> "+="	[AddAssign]	{ BIN_ADD }
  -> "-="	[SubAssign]	{ BIN_SUB }
  -> ">>="	[RshAssign]	{ BIN_RSH }
  -> "<<="	[LshAssign]	{ BIN_LSH }
  -> "&="	[BitAndAssign]	{ BIN_BITAND }
  -> "^="	[BitXorAssign]	{ BIN_BITXOR }
  -> "|="	[BitOrAssign]	{ BIN_BITOR }
  -> "="	[Assign]	{ BIN_ASSIGN }
}


(* this is the same definition as ExpressionList, and perhaps it
 * makes sense to collapse them?  the meaning of ',' is quite
 * different in the two cases.. does that matter?
 * update: now that I'm doing translation too, the difference
 * in the meanings is great enough that I think they should be
 * separate, as they are *)
nonterm Expression {
  (* ambiguous:
   *   a < b , c > (d)
   * could either be a comma-exp with two relationals, or
   * it could be creating an instance of template a with template
   * arguments b,c and ctor argument d *)
  fun merge(l,r) { E_ambig (l, r) }

  -> ae:AssignmentExpression
	[Head] { ae }

  -> e:Expression "," ae:AssignmentExpression
	[List] { E_binary (e, BIN_COMMA, ae) }
}

nonterm ForConditionOpt {
  (* empty expression is a true no-op *)
  -> empty		{ E_boolLit true }
  -> e:Expression	{ e }
}

(* this is an expression with the additional requirement that
 * it be entirely evaluable to an int at compile time
 * (the name exists simply to help document that fact; the grammar
 * cannot enforce it) *)
nonterm ConstantExpression {
  (* cppstd says 'ConditionalExpression', but gcc allows assignments
   * here too, for its dynamically-sized arrays extension; if that
   * extension is *not* enabled, we will still reject an assignment
   * expression here, but because it is not const-eval'able, rather
   * than due to grammar violation (in/k0042.cc) *)
  -> e:AssignmentExpression;
}

nonterm ConstantExpressionOpt {
  -> empty			{ None }
  -> e:ConstantExpression	{ Some e }
}


(* sm: At one point we had a FullExpression nonterminal.  I decided to
 * switch to just inserting FullExpressions into the AST at the
 * appropriate points in the action code, since it's no less clear,
 * leads to less lines of grammar code, and will perform slightly
 * better that way.
 *
 * The same could be argued of ConstantExpression, but I do think it's
 * a little clearer to have a nonterminal instead of sprinkled
 * comments, and much less added code than FullExpression was.	It's a
 * matter of taste, I guess. *)


(* ------ A.5 Statements ------ *)
(* pull the label and colon out to make things easier in gnu.gr *)
nonterm LabelAndColon {
  (* 10/20/04: The precedence specification here fixes in/c/t0018.c by
   * telling the parser to shift any __attribute__ that follows the ":". *)
  -> n:Identifier ":"	precedence(TOK_PREFER_SHIFT)
	{ unimplemented 171 }
}

(* labelled-statement *)
nonterm Statement {
  (* ambiguous:
   *   x(y);
   * can either be an Expression statement (constructor call)
   * or a BlockDeclaration (declare variable y, of type x) *)
  fun merge(l,r) { S_ambig (l, r) }

  -> n:LabelAndColon s:Statement [Label] { S_label (n, s) }

  -> "case" e:ConstantExpression ":" s:Statement [Case] { S_case (e, s) }

  -> "default" ":" s:Statement [Default] { S_default (s) }

  (* expression-statement *)
  -> s:ExpressionStatement [Expr] { s }

  (* compound-statement *)
  -> s:CompoundStatement [Compound] { s }

  (* selection-statement
   * (prefer to shift "else" over reducing by this rule) *)
  -> "if" "(" e:Condition ")" s:Statement	precedence(TOK_PREFER_SHIFT)
	[If] { S_if (e, s, S_skip) }

  (* if-then-else preferred over if-then when ambiguous *)
  -> "if" "(" e:Condition ")" s1:Statement "else" s2:Statement
	[IfElse] { S_if (e, s1, s2) }

  -> "switch" "(" e:Condition ")" s:Statement 
	[Switch] { S_switch (e, s) }

  -> "while" "(" e:Condition ")" s:Statement 
	[While] { S_while (e, s) }

  -> "do" s:Statement "while" "(" e:Expression ")" ";" 
	[DoWhile] { S_doWhile (s, FullExpression e) }

  (* I might like to rework this so both semicolons appear here instead
   * of buried in ForInitStatement; it's this way now because that is how
   * the standard does it. *)
  -> "for" "(" s1:ForInitStatement c:ConditionOpt ";" e:ForConditionOpt ")" s2:Statement
	[For] { S_for (s1, c, FullExpression e, s2) }

  -> "break" ";"			[Break] { S_break }

  -> "continue" ";"			[Continue] { S_continue }

  -> "return" e:Expression ";"		[ReturnExpr] { S_return (Some (FullExpression e)) }

  -> "return" ";"			[ReturnVoid] { S_return (None) }

  -> "goto" n:Identifier ";"		[Goto] { S_goto (n) }

  (* declaration-statement *)
  -> d:BlockDeclaration			[DeclStmt] { S_decl (d) }

  (* try-block *)
  -> s:TryBlock				[Try] { s }

  (* assembly statement *)
  -> a:AsmDefinition			[Asm] { S_asm (a) }

  (* namespace declaration *)
  -> n:NamespaceDecl			[Namespace] { S_namespaceDecl (n) }
}

nonterm ExpressionStatement {
  -> ";"		 { S_skip }
  -> e:Expression ";"	 { S_expr (FullExpression e) }
}

nonterm CompoundStatement {
  -> "{" seq:CompoundStmtHelper "}"
	[CompoundStmt] { S_compound (seq) }
}

nonterm CompoundStmtHelper {
  -> empty
	{ [] }
  -> c:CompoundStmtHelper s:AnnotatedStatement
	{ s :: c }
}

nonterm AnnotatedStatement {
  -> s:Statement a:AnnotationOpt
	[Stmt] { s }
}


(* the guard of e.g. an 'if' statement *)
nonterm Condition {
  (* ambiguous:
   *   if (A * a = 0) { /*...*/ }
   * could either be a CN_expr (mult+assign) or CN_decl (of variable 'a') *)
  fun merge(l,r) { unimplemented 198 }

  -> e:Expression
	[ExprCond] { CN_expr (FullExpression e) }

  (* variable declaration in the condition clause *)
  -> spec:TypeSpecifier decl:Declarator "=" e:AssignmentExpression
	[DeclCond] {
	  CN_decl (
	    T_type (
	      spec,
	      DC_decl (decl, Some (IN_expr e))))
	}
}

nonterm ConditionOpt {
  (* an empty condition (e.g. in a for loop) is interpreted as true *)
  -> empty		{ CN_expr (FullExpression (E_boolLit true)) }
  -> c:Condition	{ c }
}

nonterm ForInitStatement {
  (* ambiguous:
   *   x * y = z
   * could be an expression or a declaration *)
  fun merge(l,r) { unimplemented 203 }

  -> s:ExpressionStatement	{ s }
  -> s:SimpleDeclaration	{ S_decl (s) }
}


(* ----- A.6 Declarations ------ *)
(*
nonterm DeclarationSeqOpt {
  -> empty
	{ unimplemented 206 }
  -> seq:DeclarationSeqOpt d:Declaration
	{ seq->append(d); return seq; }
}
*)

nonterm Declaration {
  fun merge(l,r) { unimplemented 1302 }

  -> e:EmptyDeclaration			[Empty]			{ unimplemented 1200 }
  -> d:BlockDeclaration			[Block]			{ TF_decl (d) }
  -> f:FunctionDefinition		[Function]		{ TF_func (f) }
  -> t:TemplateDeclaration		[Template]		{ TF_template (t) }
  -> d:ExplicitInstantiation		[ExplInst]		{ d }
  (*-> e:ExplicitSpecialisation		[ExplSpec]		{ e } [> folded into TemplateDeclaration <]*)
  -> s:LinkageSpecification		[LinkageSpec]		{ s }

  (* substituted from BlockDeclaration *)
  -> a:AsmDefinition			[Asm]			{ TF_asm (a) }
  -> n:NamespaceDefinition		[NamespaceDefn]		{ n }
  -> n:NamespaceDecl			[NamespaceDecl]		{ TF_namespaceDecl (n) }
}

nonterm EmptyDeclaration {
  (* arg!  Mozilla is littered with toplevel semicolons.. *)
  -> ";"			{ unimplemented 206 }
}

nonterm BlockDeclaration {
  -> d:SimpleDeclaration;

  (* all of these have been substituted into the places BlockDeclaration occurs
   * (namely Declaration and Statement) *)
  (*-> AsmDefinition;*)
  (*-> NamespaceAliasDefinition;*)
  (*-> UsingDeclaration;*)
  (*-> UsingDirective;*)
}

(* is the DeclSpecifierSeq optional for implicit-int??
 *   no, it's for constructors, destructors, and conversion operators,
 *   all of which are C++ only, so the DeclSpecifierSeq is now mandatory
 *   (I've moved those guys into more specialised contexts)
 * ok, why is the InitDeclaratorList optional?
 *   for declaring classes and enums *)
nonterm SimpleDeclaration {
  fun merge(l,r) { unimplemented 208 }
  fun keep(d) { Factory.keep_declaration d }

  (* destructive action on 'spec' *)
  (*e.g.: int		     x			; *)
  -> spec:DeclSpecifier decllist:InitDeclaratorList ";"
	[Defn] { { spec with decllist } }

  (* a bare specifier is a type definition or forward declaration *)
  -> spec:DeclSpecifier ";"
	[Decl] { spec }

}


(* type specifier, i.e. the "int" in "int x;"
 *
 * The legal language of type specifiers is much larger than most
 * people's usage of them; for example, "int signed" is legal, as is
 * "const unsigned volatile long static int".  Reading the standard, I
 * drew up a state diagram from which the following grammar was
 * produced, and will at some point scan my drawing.
 *
 * The basic idea is to have a bitmap (UberModifiers) of all the
 * relevant keywords, to allow collecting them in any order.  Then,
 * since a type specifier can only name one type, once I see something
 * which commits the syntax to one particular kind of type specifier
 * (e.g. TS_name, or TS_simple) then I drop down into collecting a
 * possibly different set of keywords.
 *
 * I explicitly substitute UberModifierSeqOpt into the left sides of
 * the productions below as a performance optimisation to avoid
 * shift/reduce conflicts.  That is, I write
 *   ->			PQTypeName UberModifierSeqOpt
 *   -> UberModifierSeq PQTypeName UberModifierSeqOpt
 * instead of
 *   -> UberModifierSeqOpt PQTypeName UberModifierSeqOpt
 * because the latter would cause shift/reduce conflicts. *)
nonterm DeclSpecifier {
  (*fun dup(d) { unimplemented 210 }	[> prevent multi-yield <]*)

  (* TS_name: triggered by PQTypeName *)
  -> n:PQTypeName m2:UberModifierSeqOpt
	[Name] {
	  let m = m2 in
	  (* new declaration *)
	  {
	    dflags = Flags.dflags_of_modifiers m;
	    spec = TS_name (
	      Flags.cv_of_modifiers m,
	      n, (*~typenameUsed*)false);
	    decllist = [];
	  }
	}

  -> m1:UberModifierSeq n:PQTypeName m2:UberModifierSeqOpt
	[ModName] {
	  let m = m1 @ m2 in
	  {
	    dflags = Flags.dflags_of_modifiers m;
	    spec = TS_name (
	      Flags.cv_of_modifiers m,
	      n, (*~typenameUsed*)false);
	    decllist = [];
	  }
	}

  (* TS_simple: triggered by SimpleTypeSpecifier *)
  -> k1:SimpleTypeSpecifier m2:UberTypeAndModifierSeqOpt
	[Simple] {
	  let m = m2 in
	  let k = k1 :: m2 in
	  {
	    dflags = Flags.dflags_of_modifiers m;
	    spec = TS_simple (
	      Flags.cv_of_modifiers m,
	      Flags.stype_of_modifiers k);
	    decllist = [];
	  }
	}

  -> m1:UberModifierSeq k1:SimpleTypeSpecifier m2:UberTypeAndModifierSeqOpt
	[ModSimple] {
	  let m = m1 @ m2 in
	  let k = k1 :: m2 in
	  {
	    dflags = Flags.dflags_of_modifiers m;
	    spec = TS_simple (
	      Flags.cv_of_modifiers m,
	      Flags.stype_of_modifiers k);
	    decllist = [];
	  }
	}

  (* TS_elaborated, TS_classSpec, TS_enumSpec:
   * triggered by one of "class", "struct", "union", "enum", "typename",
   * with the particular instance sorted out by ElaboratedOrSpecifier *)
  -> e:ElaboratedOrSpecifier m2:UberModifierSeqOpt
	[Elab] {
	  let m = m2 in
	  let e = Flags.set_cv (Flags.cv_of_modifiers m) e in
	  {
	    dflags = Flags.dflags_of_modifiers m;
	    spec = e;
	    decllist = [];
	  }
	}

  -> m1:UberModifierSeq e:ElaboratedOrSpecifier m2:UberModifierSeqOpt
	[ModElab] {
	  let m = m1 @ m2 in
	  let e = Flags.set_cv (Flags.cv_of_modifiers m) e in
	  {
	    dflags = Flags.dflags_of_modifiers m;
	    spec = e;
	    decllist = [];
	  }
	}
}

(* choose among TS_elaborated, TS_classSpec and TS_enumSpec *)
nonterm ElaboratedOrSpecifier {
  (* Note: This can multi-yield in cases like in/k0072.cc. *)

  -> s:ElaboratedTypeSpecifier [Elab];
  -> s:ClassSpecifier [Class];
  -> s:EnumSpecifier [Enum];
}


(* nonempty sequence of UberModifiers; note that the act of combining
 * UberModifiers sets checks for and complains about duplication *)
nonterm(modifiers) UberModifierSeq {
  -> u:UberModifier			{ [u] }
  -> s:UberModifierSeq u:UberModifier	{ u :: s }
}

nonterm(modifiers) UberModifierSeqOpt {
  -> empty			{ [] }
  -> s:UberModifierSeq		{ s }
}


(* possibly empty sequence of modifiers (e.g. "static") or type
 * keywords (e.g. "int") *)
nonterm(modifiers) UberTypeAndModifierSeqOpt {
  -> empty						[Empty]		{ [] }
  -> s:UberTypeAndModifierSeqOpt u:UberModifier		[ModSeq]	{ u :: s }
  -> s:UberTypeAndModifierSeqOpt u:SimpleTypeSpecifier	[TypeSeq]	{ u :: s }
}


(* repetition of above rules when the only modifiers allowed
 * are "const" and "volatile"; this is for TypeSpecifier *)
nonterm(cv_flags) UberCVQualifierSeq {
  -> u:UberCVQualifier				{ [u] }
  -> s:UberCVQualifierSeq u:UberCVQualifier	{ u :: s }
}

nonterm(cv_flags) UberCVQualifierSeqOpt {
  -> empty			{ [] }
  -> s:UberCVQualifierSeq	{ s }
}

nonterm(modifiers) UberTypeAndCVQualifierSeqOpt {
  -> empty							{ [] }
  -> s:UberTypeAndCVQualifierSeqOpt u:UberTypeAndCVQualifier	{ u :: s }
}

nonterm(modifier) UberTypeAndCVQualifier {
  -> u:UberCVQualifier		[CV]		{ (u :> modifier) }
  -> u:SimpleTypeSpecifier	[TypeSpec]	{ (u :> modifier) }
}


(* modifiers *)
nonterm(modifier) UberModifier {
  (* storage-class-specifier *)
  -> "auto"		[Auto]		{ `UM_AUTO }
  -> "register"		[Register]	{ `UM_REGISTER }
  -> "static"		[Static]	{ `UM_STATIC }
  -> "extern"		[Extern]	{ `UM_EXTERN }
  -> "mutable"		[Mutable]	{ `UM_MUTABLE }

  (* function-specifier *)
  -> "inline"		[Inline]	{ `UM_INLINE }
  -> "virtual"		[Virtual]	{ `UM_VIRTUAL }
  (* -> "explicit"	[Explicit]	{ `UM_EXPLICIT }	(* can only appear in CDtorModifier *) *)

  (* decl-specifier terminals *)
  -> "friend"		[Friend]	{ `UM_FRIEND }
  -> "typedef"		[Typedef]	{ `UM_TYPEDEF }

  (* cv-qualifier *)
  -> "const"		[Const]		{ `UM_CONST }
  -> "volatile"		[Volatile]	{ `UM_VOLATILE }
}

(* just the cv-qualifiers *)
nonterm(cv_flag) UberCVQualifier {
  -> "const"		[Const]		{ `UM_CONST }
  -> "volatile"		[Volatile]	{ `UM_VOLATILE }
}

(* keywords that name a type, or part of one *)
nonterm SimpleTypeSpecifier {
  -> "char"		[Char]		{ `UM_CHAR }
  -> "wchar_t"		[WCharT]	{ `UM_WCHAR_T }
  -> "bool"		[Bool]		{ `UM_BOOL }
  -> "short"		[Short]		{ `UM_SHORT }
  -> "int"		[Int]		{ `UM_INT }
  -> "long"		[Long]		{ `UM_LONG }
  -> "signed"		[Signed]	{ `UM_SIGNED }
  -> "unsigned"		[Unsigned]	{ `UM_UNSIGNED }
  -> "float"		[Float]		{ `UM_FLOAT }
  -> "double"		[Double]	{ `UM_DOUBLE }
  -> "void"		[Void]		{ `UM_VOID }
}


nonterm ElaboratedTypeSpecifier {
  -> k:ClassKey n:PQTypeName	[Class] { TS_elaborated ([], k, n) }
  -> "enum" n:PQTypeName	[Enum]	{ TS_elaborated ([], TI_Enum, n) }

  (* cppstd grammar ensures "typename" is only applied to qualified
   * names, but I find that more natural to enforce during typechecking *)
  -> "typename" n:PQTypeName	[Typename] { TS_name ([], n, (*~typenameUsed*)true) }
}


(* plays role of "TypeSpecifierSeq" in cppstd; this is a
 * version of DeclSpecifier restricted to only allow "const" and
 * "volatile" UberModifiers *)
nonterm TypeSpecifier {
  (* TS_name *)
  -> n:PQTypeName cv:UberCVQualifierSeqOpt
	[Name] { TS_name (cv, n, (*~typenameUsed*)false) }

  -> cv1:UberCVQualifierSeq n:PQTypeName cv2:UberCVQualifierSeqOpt
	[QualName] { TS_name (cv1 @ cv2, n, (*~typenameUsed*)false) }

  (* TS_simple *)
  -> k1:SimpleTypeSpecifier m2:UberTypeAndCVQualifierSeqOpt
	[Simple]
	{
	  let m = m2 in
	  let k = k1 :: m2 in
	  TS_simple (
	    Flags.cv_of_modifiers m,
	    Flags.stype_of_modifiers k)
	}

  -> m1:UberCVQualifierSeq k1:SimpleTypeSpecifier m2:UberTypeAndCVQualifierSeqOpt
	[QualSimple] {
	  let m = (m1 :> modifiers) @ m2 in
	  let k = k1 :: m2 in
	  TS_simple (
	    Flags.cv_of_modifiers m,
	    Flags.stype_of_modifiers k)
	}

  (* TS_elaborated, TS_classSpec, TS_enumSpec *)
  -> e:ElaboratedOrSpecifier m2:UberCVQualifierSeqOpt
	[Elab] {
	  let m = m2 in
	  Flags.set_cv m e
	}

  -> m1:UberCVQualifierSeq e:ElaboratedOrSpecifier m2:UberCVQualifierSeqOpt
	[QualElab] {
	  let m = m1 @ m2 in
	  Flags.set_cv m e
	}
}


(* I had been separating these into typedef/enum/class names, but
 * the parser can never distinguish, so the grammar shouldn't suggest
 * that it can *)
nonterm PQTypeName {
  fun merge(l,r) { unimplemented 268 }

  -> n:PQTypeName_ncc
	[Local] { n }
  -> "::" n:PQTypeName_ncc
	[Global] { PQ_qualifier (None, [], n) }
}

(* no-colon-colon *)
nonterm PQTypeName_ncc {
  fun merge(l,r) { unimplemented 271 }

  -> n:Identifier			precedence("::")
	[Id] { PQ_name (n) }
  -> id:TemplateId			precedence("::")
	[TemplateId] { id }

  -> q:Identifier "::" n:PQTypeName_notfirst
	[Qualified] { PQ_qualifier (Some q, [], n) }
  -> q:Identifier "<" targs:TemplateArgumentListOpt ">" "::" n:PQTypeName_notfirst
	[QualifiedTemplateId] { PQ_qualifier (Some q, targs, n) }
}

(* after at least one qualifier other than "::"; 'template' has to be
 * squirreled away down here because otherwise it becomes ambiguous
 * with the 'template' at the start of an ElaboratedTypeSpecifier *)
nonterm PQTypeName_notfirst {
  fun merge(l,r) { unimplemented 276 }

  -> id:PQTypeName_ncc			precedence("::")
	[Unqual];

  (* template declaration (in/t0254.cc) *)
  -> "template" id:TemplateId		precedence("::")
	[TemplateDecl] {
	  match id with
	  | PQ_template (n, list) ->
	      PQ_template (n, TA_templateUsed :: list)
	  | _ ->
	      failwith "invalid TemplateId"
	}

  (* TEMPLATE_QUALIFIER_HACK *)
  (*-> "template" q:Identifier "::" n:PQTypeName_notfirst *)
  (*	{ unimplemented 279 } *)
  -> "template" q:Identifier "<" targs:TemplateArgumentListOpt ">" "::" n:PQTypeName_notfirst
	[TemplateQual] { unimplemented 280 }
}


nonterm EnumSpecifier {
  -> "enum" "{" list:EnumeratorListOpt "}"
	[Enum] { TS_enumSpec ([], None, list) }
  -> "enum" n:Identifier "{" list:EnumeratorListOpt "}"
	[NamedEnum] { TS_enumSpec ([], Some n, list) }
}


(* rewrote this definition so I can always tell with one token of
 * lookahead whether this is the last enumerator definition; this
 * allows an optional comma at the end, on purpose *)
nonterm EnumeratorListOpt {
  fun merge(l,r) { unimplemented 1303 }

  -> empty
	{ [] }
  -> def:EnumeratorDefinition
	{ [def] }
  -> def:EnumeratorDefinition "," list:EnumeratorListOpt
	{ def :: list }
}


nonterm EnumeratorDefinition {
  -> ename:Identifier eexpr:EnumeratorExpressionOpt
	[Enum] { { ename; eexpr; } }
}

nonterm EnumeratorExpressionOpt {
  -> empty				{ None }
  -> "=" expr:ConstantExpression	{ Some expr }
}


(* dsw: this is ambiguous and redundant with a similar thing in
 * gnu.gr; should it be here at all?
 *
 * sm: Yes it should be here.  First, we don't always use the gnu.gr
 * extension module.  Second, gnu.gr's AsmDefinition *extends* this
 * one, which is how it should be.  This is the AsmDefinition for
 * C++. *)
nonterm AsmDefinition {
  -> "asm" "(" s:StringLiteral ")" ";"	{ unimplemented 288 }
}


nonterm LinkageSpecification {
  -> "extern" n:TOK_STRING_LITERAL "{" tu:TranslationUnit "}"
	{ TF_linkage (n, tu) }

  -> "extern" n:TOK_STRING_LITERAL tf:Declaration
	{ TF_one_linkage (n, tf) }
}


(* ------ A.7 Declarators ------ *)
(* -- declarator -- *)
(* a declarator is the "x" in a declaration like "int x" *)

nonterm InitDeclaratorList {
  fun merge(l,r) { unimplemented 1003 }

  -> d:InitDeclarator
	[InitDecl] { [d] }
  -> list:InitDeclaratorList "," d:InitDeclarator
	[InitDecls] { d :: list }
}

(* obsolete now that I've substituted it into SimpleDeclaration *)
(*
nonterm InitDeclaratorListOpt {
  -> empty
	{ unimplemented 293 }
  -> list:InitDeclaratorList
	{ unimplemented 294 }
}
*)


nonterm InitDeclarator {
  (* ambiguous:
   *   int f(x *y);
   * could be declaring a variable called "f" with ctor-initialiser "(x*y)",
   * or it could be declaring a function called "f" which accepts a pointer
   * to an 'x' as a parameter
   *
   * another example:
   *   int m(int (n));
   * could be declaring a variable called "m" with ctor-initialiser "int (n)"
   * which itself is a call to the constructor for "int", or it could be
   * declaring a function called "m" with an integer parameter called "n",
   * the latter surrounded by a redundant set of parens *)
  fun merge(l,r) { DC_ambig (l, r) }

  -> d:Declarator i:InitialiserOpt	(* (int)  x (= 5) *)
	[Decl] { DC_decl (d, i) }
}

nonterm InitialiserOpt {
  -> empty { None }
  -> i:Initialiser { Some i }
}

nonterm Initialiser {
  -> "=" i:SimpleInitialiserClause
	[Init] { i }

  -> "(" args:ExpressionList ")"
	[CtorInit] { IN_ctor (args) }

  (* NOTE: there is no alternative for "(" ")"! *)
  (* see [cppstd. sec. 8.5 para 8] *)
}

nonterm SimpleInitialiserClause {
  -> e:AssignmentExpression		(* scalar *)
	[Expr] { IN_expr e }
  -> c:CompoundInitialiser		(* array/structure initialiser *)
	[Compound] { c }
}

(* this nonterminal exists so that extensions can augment it with
 * possibilities for designated initialisers *)
nonterm InitialiserClause {
  -> init:SimpleInitialiserClause
	{ unimplemented 302 }
}

nonterm CompoundInitialiser {
  (* zero whatever it is *)
  -> "{" "}"  { unimplemented 304 }

  (* array/structure initialiser *)
  -> "{" list:InitialiserList CommaOpt "}"  { unimplemented 303 }
}

(* useful syntactic quirk *)
nonterm CommaOpt {
  -> empty { unimplemented 1214 }
  -> "," { unimplemented 1215 }
}

nonterm InitialiserList {
  fun dup(i) { unimplemented 305 }	(* prevent multi-yield *)

  -> init:InitialiserClause
	{ unimplemented 306 }

  (* destructive action on 'list' *)
  -> list:InitialiserList "," init:InitialiserClause
	{ unimplemented 307 }
}


(* perhaps confusing name correspondence:
 *   The AST name "Declarator" corresponds to the grammar name
 *   "InitDeclarator"; the AST name "IDeclarator" (inner declarator)
 *   corresponds to the grammar name "Declarator"
 * this name shift simply reflects the different interests of the
 * parser vs. subsequent phases of analysis
 *
 * regex for this nonterm: (PrefixDeclarator)* DirectDeclarator *)
nonterm Declarator {
  -> p:PrefixDeclarator d:Declarator
	[Prefix] { p d }
  -> d:DirectDeclarator
	[Direct] { d }
}

nonterm PrefixDeclarator {
  -> "*" cv:CVQualifierSeqOpt
	[Ptr] { fun d -> D_pointer (cv, d) }
  -> "&" cv:CVQualifierSeqOpt
	[Re] { fun d -> D_reference (cv, d) }
  -> n:PtrToMemberName "*" cv:CVQualifierSeqOpt
	[MemPtr] { fun d -> D_ptrToMember (n, cv, d) }
}

nonterm DirectDeclarator {
  (* it doesn't matter how this was classified before, because a
   * declarator binds a new name, so it shadows any prior definitions;
   * note: this rule handles constructor names!
   * note: this also handles operator names! *)
  -> n:IdExpression
	[IdDecl] { D_name (Some n) }

  (* dtor *)
  -> n:PQDtorName
	[DtorDecl] { D_name (Some n) }

  (* function declarator; the return type comes from the type
   * specifier that precedes this *)
  -> d:DirectDeclarator				(* name of function *)
     "(" params:ParameterDeclarationClause ")"	(* parameters *)
     cv:CVQualifierSeqOpt			(* optional "const" *)
     e:ExceptionSpecificationOpt		(* optional "throw" clause *)
	[FuncDecl] { Factory.make_d_func d params cv e }

  (* array with optional size *)
  -> d:DirectDeclarator "[" sz:ConstantExpressionOpt "]"
	[ArrayDecl] { Factory.make_d_array d sz }

  (* precedence grouping; must be recorded in the AST for disambiguation *)
  -> "(" d:Declarator ")"
	[ParenDecl] { D_grouping (d) }
}

(* I choose to encode ctor and dtor names as ordinary PQNames, because
 * the parser can't tell them apart from other PQNames; but the dtor
 * must be handled specially because if I just allowed "~" before any
 * name, then I couldn't tell if the expression "~a" is unary "~" or
 * the name of a destructor.  Destructor names are encoded by prepending
 * a "~" to them, so later phases of analysis will have to look for that.
 * (I notice the standard calls this PseudoDestructorName; I'll stick with
 * my terminology.) *)
nonterm PQDtorName {
  fun merge(l,r) { unimplemented 317 }

  -> "~" n:Identifier
	{ PQ_name ("~" ^ n) }
  -> "~" n:Identifier "<" list:TemplateArgumentListOpt ">"
	{ PQ_template ("~" ^ n, list) }

  (* as above for PQName_no_colon_colon, I'm temporarily removing an
   * ambiguity that relates to namespaces (e.g. "::F::~F()") *)
  (*-> q:Qualifier rhs:PQDtorName  { unimplemented 320 } *)
  -> q:Identifier "::" rhs:PQDtorName
	{ PQ_qualifier (Some q, [], rhs) }

  -> q:Identifier "<" targs:TemplateArgumentListOpt ">" "::" rhs:PQDtorName
	{ PQ_qualifier (Some q, targs, rhs) }

  (* TEMPLATE_QUALIFIER_HACK *)
  (*-> "template" q:Identifier "::" rhs:PQDtorName *)
  (*	{ unimplemented 323 } *)
  -> "template" q:Identifier "<" targs:TemplateArgumentListOpt ">" "::" rhs:PQDtorName
	{ PQ_qualifier (Some q, TA_templateUsed :: targs, rhs) }

  (* this rule from cppstd is partially subsumed by the "template" hack *)
  (*-> ColonColonOpt NestedNameSpecifier "template" TemplateId "::" "~" TypeName; *)
}


(* syntax that precedes "*" in the pointer-to-member declarator syntax *)
nonterm PtrToMemberName {
  fun merge(l,r) { unimplemented 325 }

  -> n:IdExpression "::"	{ unimplemented 326 }
}


nonterm CVQualifierSeqOpt {
  -> empty			{ [] }
  -> s:CVQualifierSeq		{ s }
}

nonterm CVQualifierSeq {
  -> q:CVQualifier			{ [q] }
  -> s:CVQualifierSeq q:CVQualifier	{ q :: s }
}

nonterm CVQualifier {
  -> "const"			[Const]		{ `UM_CONST }
  -> "volatile"			[Volatile]	{ `UM_VOLATILE }
}


(* -- type-id -- *)
(* a type-id is like a declaration of one thing, but without the variable name;
 * it is, for example, what appears inside the parens of a typecast *)
nonterm TypeId {
  -> spec:TypeSpecifier decl:AbstractDeclaratorOpt
	[TypeId] { T_type (spec, DC_decl (decl, None)) }
}

nonterm AbstractDeclaratorOpt {
  -> empty			{ D_name (None) }
  -> d:AbstractDeclarator	{ d }
}

(* an abstract declarator (not opt) must have *some* ground syntax in it *)
nonterm AbstractDeclarator {
  -> p:PrefixDeclarator d:AbstractDeclaratorOpt
	{ p d }
  -> d:DirectAbstractDeclarator
	{ d }
}

nonterm DirectAbstractDeclaratorOpt {
  -> empty				{ D_name (None) }
  -> d:DirectAbstractDeclarator		{ d }
}

(* this also must have some ground syntax *)
nonterm DirectAbstractDeclarator {
  (* note: the "opt" in the DirectAbstractDeclarator part of the
   * function type constructor creates an ambiguity:
   *   typedef int x;
   *   int foo(int (x));
   * Is the parameter an int, or a function accepting an 'x'?
   *
   * This is addressed by cppstd 8.2 para 7; see D_name_tcheck.
   *
   * This ambiguity doesn't show up until ParameterDeclaration, below. *)

  (* function *)
  -> d:DirectAbstractDeclaratorOpt
     "(" args:ParameterDeclarationClause ")"
     cv:CVQualifierSeqOpt
     e:ExceptionSpecificationOpt
	{ Factory.make_d_func d args cv e }

  (* array with optional size *)
  -> d:DirectAbstractDeclaratorOpt "[" sz:ConstantExpressionOpt "]"
	{ Factory.make_d_array d sz }

  (* precedence grouping; shouldn't need to record this in AST, but
   * I will for consistency with Declarator *)
  -> "(" d:AbstractDeclarator ")"
	{ D_grouping (d) }
}


nonterm ParameterDeclarationClause {
  -> empty				(* no args *)
	{ [] }
  -> p:ParameterDeclarationList		(* some args *)
	{ p }
}

(* little bending over backwards here to accomodate FakeList *)
nonterm ParameterDeclarationList {
  fun merge(l,r) { unimplemented 1300 }

  (* last (and perhaps only) arg is "..." *)
  -> e:Ellipsis
	[VarArg] { [e] }

  (* last arg is "...", and 2nd-to-last is not separated by
   * a comma from the "..." *)
  -> d:ParameterDeclaration e:Ellipsis
	[NamedVarArg] { [d; e] }

  (* last arg is not "..." *)
  -> d:ParameterDeclaration
	[Param] { [d] }

  (* argument then "," then arg or "..." or list *)
  -> d:ParameterDeclaration "," l:ParameterDeclarationList
	[Params] { d :: l }
}

nonterm Ellipsis {
  -> "..."
	[Ellipsis] { Factory.make_ellipsis_type_id () }
}

nonterm ParameterDeclaration {
  fun merge(l,r) { T_ambig (l, r) }

  (* NOTE: The 'register' keyword is simply ignored. *)

  -> s:TypeSpecifier pd:ParameterDeclarator
	[Parm] { T_type (s, pd) }
  -> "register" s:TypeSpecifier pd:ParameterDeclarator
	[RegParm1] { T_type (s, pd) }
  -> s:TypeSpecifier "register" pd:ParameterDeclarator
	[RegParm2] { T_type (s, pd) }
}

nonterm ParameterDeclarator {
  (* ambiguity:
   *   int (x)
   * is either type "int" with Declarator "(x)", or
   * it could be type "int f(x q)" such that "(x)" is an
   * AbstractDeclarator
   *
   * see D_name_tcheck in tcheck.cc for resolution *)
  fun merge(l,r) { DC_ambig (l, r) }

  -> d:UnqualifiedDeclarator e:DefaultValueOpt
	[Decl] { DC_decl (d, e) }

  -> d:AbstractDeclaratorOpt e:DefaultValueOpt
	[AbstractDecl] { DC_decl (d, e) }
}

nonterm DefaultValueOpt {
  -> empty { None }
  -> "=" e:AssignmentExpression { Some (IN_expr e) }
}


(* -- function definition -- *)
nonterm FunctionDefinition {
  (* whereas the std merges c/dtors and ordinary functions by making
   * the DeclSpecifier optional, I split cases; this way in the common
   * case where I can clearly see a return type, ctor is ruled out;
   * in fact I wonder if there will ever be an ambiguity, since ordinary
   * functions always have at least two words before "(" while ctors
   * always have just one.. *)
  fun keep(f) { Factory.keep_function_definition f }

  (* in/c/t0015.c contains some code that is not legal C++, though it
   * is legal K&R C, but which nonetheless triggers a FunctionDefinition
   * merge in C++ mode:
   *   x(y) {}
   * could either have 'x' as return type and 'y' as "function" name,
   * but missing the D_func, or 'x' as constructor name and 'y' as a
   * parameter type.  So I will cancel any FunctionDefinition whose
   * declarator doesn't have a D_func at the bottom. *)
  fun merge(l,r) { unimplemented 1304 }

  (* ordinary function: *)
  (* return type      name/params   body *)
  -> r:DeclSpecifier  d:FDDeclarator  b:FunctionBody
	[Ordinary] {
	  (* new function_definition *)
	  {
	    fdflags = r.dflags;
	    retspec = r.spec;
	    name_and_params = DC_decl (d, None);
	    inits = [];
	    fbody = b;
	    handlers = [];
	  }
	}

  (* 2005-03-09: I didn't even realise this was possible for non-ctors *)
  (* return type      name/params	     body	     handlers *)
  -> r:DeclSpecifier  d:FDDeclarator  "try"  b:FunctionBody  h:HandlerSeq
	[OrdinaryTry] {
	  (* new function_definition *)
	  {
	    fdflags = r.dflags;
	    retspec = r.spec;
	    name_and_params = DC_decl (d, None);
	    inits = [];
	    fbody = b;
	    handlers = h;
	  }
	}

  (* I've now substituted the RHSs of CDtorModifierOpt, to eliminiate
   * a few s/r conflicts at the toplevel of parsing (where they are
   * the most harmful to performance) *)

  (* constructor, destructor or conversion operator *)
  (* "explicit"?	 name/params	 member inits	       body *)
  -> m:CDtorModifierSeq  d:FDDeclarator  c:CtorInitialiserOpt  b:FunctionBody
	[CDtorMod] {
	  (* new function_definition *)
	  {
	    fdflags = m;
	    retspec = TS_simple ([], ST_CDtor);
	    name_and_params = DC_decl (d, None);
	    inits = c;
	    fbody = b;
	    handlers = [];
	  }
	}
  -> (*no modifier*)	 d:FDDeclarator  c:CtorInitialiserOpt  b:FunctionBody
	[CDtor] {
	  (* new function_definition *)
	  {
	    fdflags = [];
	    retspec = TS_simple ([], ST_CDtor);
	    name_and_params = DC_decl (d, None);
	    inits = c;
	    fbody = b;
	    handlers = [];
	  }
	}

  (* ctor with a try block *)
  (* "explicit"?	 name/params	      member inits	   body		  handlers *)
  -> m:CDtorModifierSeq  d:FDDeclarator "try" c:CtorInitialiserOpt b:FunctionBody h:HandlerSeq
	[CDtorTryMod] {
	  (* new function_definition *)
	  {
	    fdflags = m;
	    retspec = TS_simple ([], ST_CDtor);
	    name_and_params = DC_decl (d, None);
	    inits = c;
	    fbody = b;
	    handlers = h;
	  }
	}
  -> (*no modifier*)	 d:FDDeclarator "try" c:CtorInitialiserOpt b:FunctionBody h:HandlerSeq
	[CDtorTry] {
	  (* new function_definition *)
	  {
	    fdflags = [];
	    retspec = TS_simple ([], ST_CDtor);
	    name_and_params = DC_decl (d, None);
	    inits = c;
	    fbody = b;
	    handlers = h;
	  }
	}
}

(* function definition declarator; must have D_func at the
 * bottom; moved this down from FunctionDefinition itself
 * to get earlier parse filtering for in/k0041.cc *)
nonterm FDDeclarator {
  fun keep(d) {
    if not (Query.bottom_is_dfunc d) then
      (* rejecting FDDeclarator w/o D_func at bottom *)
      false
    else
      true
  }

  -> d:Declarator;
}

nonterm FunctionBody -> s:CompoundStatement;

nonterm CtorInitialiserOpt {
  -> empty				{ [] }
  -> ":" list:MemInitialiserList	{ list }
}


(* ------ A.8 Classes ------ *)
nonterm ClassSpecifier {
  -> k:ClassKey n:ClassHeadNameOpt b:BaseClauseOpt "{" memb:MemberDeclarationSeqOpt "}"
	[ClassSpec] { TS_classSpec ([], k, n, b, memb) }
}

(* this is the name portion of what the standard calls "ClassHead" *)
nonterm ClassHeadNameOpt {
  fun merge(l,r) { unimplemented 371 }

  -> empty			[None]		{ None }
  -> n:ClassHeadName		[Some]		{ Some n }
}

(* a possibly-qualified Identifier or TemplateId *)
nonterm ClassHeadName {
  fun merge(l,r) { unimplemented 374 }

  -> n:Identifier		precedence("::")
	[Id] { PQ_name (n) }
  -> t:TemplateId		precedence("::")
	[TemplateId] { t }

  -> n:Identifier "::" rest:ClassHeadName
	[Qualified] { PQ_qualifier (Some n, [], rest) }
  -> n:Identifier "<" targs:TemplateArgumentListOpt ">" "::" rest:ClassHeadName
	[QualifiedTemplate] { PQ_qualifier (Some n, targs, rest) }

  (* TEMPLATE_QUALIFIER_HACK *)
  (*-> "template" n:Identifier "::" rest:ClassHeadName *)
  (*	{ unimplemented 379 } *)
  -> "template" n:Identifier "<" targs:TemplateArgumentListOpt ">" "::" rest:ClassHeadName
	[TemplateQualified] { PQ_qualifier (Some n, TA_templateUsed :: targs, rest) }
}

nonterm ClassKey {
  -> "class"		[Class]  { TI_Class }
  -> "struct"		[Struct] { TI_Struct }
  -> "union"		[Union]  { TI_Union }
}


(* I'm using an encapsulated ASTList to avoid right recursion,
 * since there are often many members of classes *)
nonterm MemberDeclarationSeqOpt {
  fun merge(l,r) { unimplemented 1305 }
  fun dup(m) { unimplemented 384 }		(* prevent multi-yield *)

  -> empty
	[Empty] { [] }

  (* gcc allows multiple semicolons in a row in a member declaration
   * list; it would be nontrivial to confine this flexibility to an
   * extension, and it's not that big a deal, so we just tolerate it
   * always *)
  -> list:MemberDeclarationSeqOpt ";"
	[Semicolon] { list }

  (* destructive actions on 'list' *)
  -> list:MemberDeclarationSeqOpt decl:MemberDeclaration
	[Decl] { decl :: list }

  (* explicitly include access specifiers in the AST, instead of
   * propagating them in the parser, to avoid the complexities of
   * maintaining the state in the parser context *)
  -> list:MemberDeclarationSeqOpt k:AccessSpecifier ":"
	[Access] { MR_access (k) :: list }
}

nonterm AccessSpecifier {
  -> "public"		[Public]	{ AK_PUBLIC }
  -> "private"		[Private]	{ AK_PRIVATE }
  -> "protected"	[Protected]	{ AK_PROTECTED }
}

nonterm MemberDeclaration {
  fun merge(l,r) { unimplemented 1306 }

  (* destructive action on 'spec'
   * member fn decl, or data member *)
  -> spec:DeclSpecifier decllist:MemberDeclaratorList ";"
	[Member] {
	  (* TODO: cancel embedded declarations *)
	  let spec = { spec with decllist } in
	  if not (Factory.keep_declaration spec) then
	    cancel "TYPENAME ::NAME"
	  else
	    MR_decl (spec)
	}

  (* inner class or enum with no instance defined *)
  -> spec:DeclSpecifier ";"
	[InnerSUE] {
	  (* if the type specifier doesn't start with 'class'
	   * or 'enum' then this is useless, and might be
	   * ambiguous with superclass member publication, so
	   * cancel it [cppstd 9.2 para 7] *)
	  match spec.spec with
	  | TS_elaborated _
	  | TS_classSpec _
	  | TS_enumSpec _ ->
	      (* ok *)
	      MR_decl (spec)
	  | _ ->
	      cancel "bare DeclSpecifier not starting with type keyword"
	}

  (* publishing a superclass member; ambiguous with inner class
   * declaration (above) and ctor declaration (below), hence the
   * need for cancellation in both of those two
   *
   * equivalent to "using n ;" so parse it as such *)
  -> n:PQualifiedId ";"
	[OldUsingDecl] { MR_usingDecl (n) }

  (* the general form *)
  -> "using" (*typename?*) n:IdExpression ";"
	[UsingDecl] { MR_usingDecl (n) }

  (* inline function definition; includes c/dtor definitions *)
  -> f:FunctionDefinition
	[InlineFunc] { MR_func f }

  (* declaration (with no definition) of a c/dtor or conversion
   * operator function *)
  -> d:CDtorProtoDecl
	[CDtor] { MR_decl (d) }

  (* note above that "explicit" and "virtual" can't be mixed because the former
   * is for ctors only and the latter can't be used with ctors (so a later stage
   * of processing will filter it out) *)

  (* member template *)
  -> d:TemplateDeclaration
	[MemberTemplate] { MR_template (d) }
}

(* declaration (with no definition) of a c/dtor or conversion
 * operator function *)
nonterm CDtorProtoDecl {
  (* Q: what about pure virtual? *)
  (* A: it's part of the MemberDeclarator *)
  -> dflags:CDtorModifierSeq d:MemberDeclarator ";"
	[ModDecl] {
	  {
	    dflags;
	    spec = TS_simple ([], ST_CDtor);
	    decllist = [d];
	  }
	}
  -> (*no modifier*) d:MemberDeclarator ";"
	[Decl] {
	  (* does the declarator construct a function type?
	   * if not, this might be ambiguous (superclass
	   * member publication), so cancel the entire reduction *)
	  if not (Query.declr_is_func d) then
	    cancel "non-function c/dtor"
	  else
	    {
	      dflags = [];
	      spec = TS_simple ([], ST_CDtor);
	      decllist = [d];
	    }
	}
}

nonterm MemberDeclaratorList {
  -> d:MemberDeclarator
	{ [d] }
  -> list:MemberDeclaratorList "," d:MemberDeclarator
	{ d :: list }
}

(* this returns a full Declarator, instead of an IDeclarator, because
 * the grammar doesn't nest MemberDeclarators, and because that way I
 * have a place to return the "=0" of a pure virtual function, and also
 * a place to put member initialisers *)
nonterm MemberDeclarator {
  -> d:Declarator
	{ DC_decl (d, (*~init*)None) }

  (* here I merge two cases (PureSpecifier and ConstantInitialiser) that
   * the std splits; given that the parser doesn't track at this level
   * whether 'd' is a function type or not, and it can't tell the
   * difference between PureSpecifier and ConstantInitialiser just by
   * looking at their syntax, we'd be disambiguating this later anyway *)
  -> d:Declarator "=" e:ConstantExpression	(* pure, and member inits *)
	{ DC_decl (d, Some (IN_expr e)) }

  -> n:IdentifierOpt ":" e:ConstantExpression	(* bitfield *)
	{
	  let n = BatOption.map (fun n -> PQ_name n) n in
	  DC_decl (D_bitfield (n, e), (*~init*)None)
	}
}

nonterm IdentifierOpt {
  -> empty		{ None }
  -> n:Identifier	{ Some n }
}


(* modifier flags allowed in front of constructors ("explicit"),
 * destructors ("virtual") and conversion functions (none); plus,
 * "inline" is allowed with any of them..
 *
 * NOTE: to avoid a syntactic ambiguity with the ctor syntax "Foo(x)",
 * the set of flags here must not include "static" or "typedef"; see
 * the action function associated with MemberDeclaration's first production *)
nonterm CDtorModifier {
  -> "explicit"		[Explicit]	{ `UM_EXPLICIT }
  -> "virtual"		[Virtual]	{ `UM_VIRTUAL }
  -> "inline"		[Inline]	{ `UM_INLINE }

  (* (in/t0527.cc) this is to allow befriending another class's constructor *)
  -> "friend"		[Friend]	{ `UM_FRIEND }
}

nonterm CDtorModifierSeq {
  -> m:CDtorModifier				{ [m] }
  -> s:CDtorModifierSeq m:CDtorModifier		{ m :: s }
}

(* I substituted this into everywhere it occurred *)
(*
nonterm CDtorModifierSeqOpt {
  -> empty			{ unimplemented 414 }
  -> m:CDtorModifierSeq		{ unimplemented 415 }
}
*)


(* ------ A.9 Derived classes ------ *)
nonterm BaseClauseOpt {
  -> empty			{ [] }
  -> ":" b:BaseSpecifierList	{ b }
}

nonterm BaseSpecifierList {
  (* NOTE: Making this nonterminal right-recursive prevents this merge.
   * However, the resulting value from this merge is dropped soon after,
   * so we return an empty list and drop both alternatives. *)
  fun merge(l,r) { [] }

  -> b:BaseSpecifier
	[Head] { [b] }
  -> list:BaseSpecifierList "," b:BaseSpecifier
	[Tail] { b :: list }
}


(* TODO: spec allows leading "::" on the PQClassName *)
nonterm BaseSpecifier {
  -> cname:PQClassName
	{ { is_virtual = false; access = AK_UNSPECIFIED; cname; } }
  -> "virtual" access:AccessSpecifierOpt cname:PQClassName
	{ { is_virtual = true; access; cname; } }
  -> access:AccessSpecifier is_virtual:VirtualOpt cname:PQClassName
	{ { is_virtual; access; cname; } }
}

nonterm VirtualOpt {
  -> empty	{ false }
  -> "virtual"	{ true }
}

(* if the access specifier is missing, then it defaults to private
 * when inherited by a class, and public when inherited by a struct;
 * typechecking will replace AK_UNSPECIFIED with the right thing later *)
nonterm AccessSpecifierOpt {
  -> empty		{ AK_UNSPECIFIED }
  -> k:AccessSpecifier	{ k }
}

nonterm PQClassName {
  fun merge(l,r) { unimplemented 427 }

  -> n:PQTypeName [Name];
}


(* ------ A.10 Special member functions ------ *)
nonterm ConversionFunctionId {
  -> "operator" t:ConversionTypeId
	{ ON_conversion (t) }
}

nonterm ConversionTypeId {
  -> s:TypeSpecifier d:ConversionDeclaratorOpt
	[ConvType] { T_type (s, DC_decl (d, (*~init*)None)) }
}

(* collects the stars that might follow a type specifier in a
 * conversion function (for converting to pointer type) *)
nonterm ConversionDeclaratorOpt {
  (* this rule is given low precedence so that if there are
   * stars (etc.) following, they will be considered to be part
   * of the conversion operator's name (cppstd 12.3.2 para 4);
   * there is still an S/R conflict for "::" and I'm not sure how
   * to resolve that one... *)
  -> empty			precedence(TOK_PREFER_SHIFT)
	{ D_name ((*~name*)None) }

  -> d:ConversionDeclarator
	{ d }
}

nonterm ConversionDeclarator {
  -> p:PrefixDeclarator d:ConversionDeclaratorOpt
	[ConvDecl] { p d }
}


nonterm MemInitialiserList {
  -> i:MemInitialiser
	{ [i] }
  -> list:MemInitialiserList "," i:MemInitialiser
	{ i :: list }
}

nonterm MemInitialiser {
  -> mname:MemInitialiserId "(" args:ExpressionListOpt ")"
	[MemInit] { { mname; args; } }
}

(* the std splits cases on whether we're calling a base class ctor
 * or initialising a field; I'll simply call both a PQName, and
 * then in typechecking make sure that the latter case does not
 * have any qualifiers (because in most cases the parser can't make
 * the distinction so it would fall through to typechecking anyway) *)
nonterm MemInitialiserId {
  (* PQTypeName includes the 'identifier' case, and is otherwise
   * exactly right for the 'base class' case, so just use it *)
  -> n:PQTypeName;
}


(* ------ A.11 Overloading ------ *)
nonterm OperatorFunctionId {
  -> "operator" od:Operator;
}

(* this nonterm('tis) is only used in the OperatorFunctionId context,
 * so go ahead and have it return a full OperatorName *)
nonterm Operator {
  (* ambiguity:
   *   void operator delete [] () ;
   * could be operator "delete[]", or
   * it could be an array of operator "delete"
   *
   * to resolve this I'll specify that the parser should always
   * prefer to shift when it has seen "new" or "delete" and the
   * lookahead token is "[" *)

  -> "new" precedence(TOK_PREFER_SHIFT)
	[New]		{ ON_new }
  -> "delete" precedence(TOK_PREFER_SHIFT)
	[Delete]	{ ON_delete }
  -> "new" "[" "]"
	[NewArray]	{ ON_newArray }
  -> "delete" "[" "]"
	[DeleteArray]	{ ON_deleteArray }

  -> op:OverloadableOp
	[Op]		{ ON_operator op }
}

nonterm OverloadableOp {
  -> "!"	[Not]		{ OP_NOT }
  -> "~"	[BitNot]	{ OP_BITNOT }

  -> "++"	[PlusPlus]	{ OP_PLUSPLUS }
  -> "--"	[MinusMinus]	{ OP_MINUSMINUS }

  -> "+"	[Plus]		{ OP_PLUS }
  -> "-"	[Minus]		{ OP_MINUS }
  -> "*"	[Star]		{ OP_STAR }

  -> "/"	[Div]		{ OP_DIV }
  -> "%"	[Mod]		{ OP_MOD }
  -> "<<"	[Lsh]		{ OP_LSH }
  -> ">>"	[Rsh]		{ OP_RSH }
  -> "&"	[Ampersand]	{ OP_AMPERSAND }
  -> "^"	[BitXor]	{ OP_BITXOR }
  -> "|"	[BitOr]		{ OP_BITOR }

  -> "="	[Assign]	{ OP_ASSIGN }
  -> "+="	[AddEq]		{ OP_ADDEQ }
  -> "-="	[SubEq]		{ OP_SUBEQ }
  -> "*="	[MulEq]		{ OP_MULEQ }
  -> "/="	[DivEq]		{ OP_DIVEQ }
  -> "%="	[ModEq]		{ OP_MODEQ }
  -> "<<="	[LshEq]		{ OP_LSHEQ }
  -> ">>="	[RshEq]		{ OP_RSHEQ }
  -> "&="	[BitAndEq]	{ OP_BITANDEQ }
  -> "^="	[BitXorEq]	{ OP_BITXOREQ }
  -> "|="	[BitOrEq]	{ OP_BITOREQ }

  -> "=="	[Eq]		{ OP_EQUAL }
  -> "!="	[Neq]		{ OP_NOTEQUAL }
  -> "<"	[Lt]		{ OP_LESS }
  -> ">"	[Gt]		{ OP_GREATER }
  -> "<="	[Le]		{ OP_LESSEQ }
  -> ">="	[Ge]		{ OP_GREATEREQ }

  -> "&&"	[And]		{ OP_AND }
  -> "||"	[Or]		{ OP_OR }

  -> "->"	[Arrow]		{ OP_ARROW }
  -> "->*"	[ArrowStar]	{ OP_ARROW_STAR }

  -> "[" "]"	[Brackets]	{ OP_BRACKETS }
  -> "(" ")"	[Parens]	{ OP_PARENS }
  -> ","	[Comma]		{ OP_COMMA }
}


(* ------ A.12 Templates ------ *)
(* I recognise this syntax, but ignore it *)
(* 8/15/04: it is now folded inline where it occurs *)
(*
nonterm ExportOpt {
  -> empty;
  -> "export";
}
*)

nonterm TemplateDeclaration {
  fun merge(l,r) { unimplemented 1308 }

  (* these are the std's rules for template declarations and specialisations:
   *   -> ExportOpt "template" "<" TemplateParameterList ">" Declaration;
   *   -> "template" "<" ">" Declaration;
   * I've unified them by making the parameter list and 'export' optional
   * in both cases. *)

  (* I have expanded 'Declaration' as appropriate, which cuts down on
   * the filtering work and also makes the semantic values available
   * in a more convenient context.  In particular, I dug down several
   * levels to get 'ClassSpecifier' for template classes, which
   * dramatically cuts down on the vestigial stuff the std's grammar
   * would have potentially included. *)

  (* template function definition *)
  -> plist:TemplatePreamble def:FunctionDefinition
	{
	  if Query.any_have_default_args plist then
	    (* Function templates and definitions of members of class
	     * templates cannot have default arguments (14.1p9).
	     * Reject here because failure to do so can lead to an
	     * unhandled ambiguity (t0463.cc). *)
	    cancel "template function defn with default args"
	  else
	    TD_func (plist, def)
	}

  (* template function definition, or template class or data member decl/defn *)
  -> plist:TemplatePreamble d:SimpleDeclaration
	{ TD_decl (plist, d) }

  (* definition of a template member *)
  -> plist:TemplatePreamble td:TemplateDeclaration
	{ TD_tmember (plist, td) }

  (* as a toplevel form, this is a specialisation of a template class
   * constructor; as a class member, it is a declaration of a
   * templatised constructor *)
  -> plist:TemplatePreamble d:CDtorProtoDecl
	{ TD_decl (plist, d) }
}

(* the "template <...>" stuff *)
nonterm TemplatePreamble {
  (* 8/15/04: substituted 'ExportOpt' inline since it gives rise to
   * easily-removed S/R conflicts (continuing to ignore it though) *)

  (* template declaration *)
  -> "template" "<" plist:TemplateParameterList ">"
	[Temlate] { plist }
  -> "export" "template" "<" plist:TemplateParameterList ">"
	[ExportTemplate] { plist }

  (* explicit specialisation *)
  -> "template" "<" ">"
	[ExplSpecTemplate] { [] }
  -> "export" "template" "<" ">"
	[ExplSpecExportTemplate] { [] }
}

nonterm TemplateParameterList {
  (* unfortunately, while we can record an ambiguous template parameter
   * list, we do not currently disambiguate it properly; see in/t0465.cc *)
  fun merge(l,r) { unimplemented 490 }

  (* non-template type parameter *)
  -> p:TypeParameter next:TemplateParameterListContinuation
	{ p :: next }
}

nonterm TypeParameter {
  fun merge(l,r) { TP_ambig (l, r) }

  (* non-template type parameter *)
  -> ClassOrTypename i:IdentifierOpt t:DefaultTypeOpt
	[TyParam] { TP_type (i, t)  }

  (* non-type parameter *)
  -> p:ParameterDeclaration
	[NonTyParam] {
	  (* if the specifier is a TS_elaborated, then it could be a type
	   * parameter; cppstd 14.1 para 3 seems to say that in that case it
	   * always *is* a type parameter *)
	  if Query.can_be_type_param (Query.spec_of_type_id p) then
	    cancel "template parameter can be type param"
	  else
	    TP_nontype (p)
	}

  (* template type parameter *)
  -> "template" "<" pl:TemplateParameterList ">" "class" i:IdentifierOpt t:DefaultTemplateOpt
	[TemplTyParam] { unimplemented 1231 }
}

(* what comes after a template paramter: nothing, or else
 * a comma and then more parameters *)
nonterm TemplateParameterListContinuation {
  fun merge(l,r) { unimplemented 494 }

  -> empty				{ [] }
  -> "," next:TemplateParameterList	{ next }
}

nonterm ClassOrTypename {
  -> "class"	{ }
  -> "typename" { }
}

nonterm DefaultTypeOpt {
  -> empty			{ None }
  -> "=" t:TypeId		{ Some t }
}

nonterm DefaultTemplateOpt {
  -> empty			{ None }
  -> "=" t:IdExpression		{ Some t }
}


nonterm TemplateArgumentListOpt {
  -> empty			{ [] }
  -> list:TemplateArgumentList	{ List.rev list }
}

nonterm TemplateId {
  -> n:Identifier "<" list:TemplateArgumentListOpt ">"
	[Identifier] { PQ_template (n, list) }

  (* 9/21/04: Added this possibility (e.g. d0103.cc). *)
  -> on:OperatorFunctionId "<" list:TemplateArgumentListOpt ">"
	(* Note: This leaks 'on', and isn't quite as operator-like
	 * as PQ_operator, so I'm not convinced it behaves perfectly... *)
	[Operator] { unimplemented 504 }

  (* I suspect this one is needed too, but the problem is that
   * 'getOperatorName' loses information for conversion operators
   * (they all map to the same string).  So, I'll leave it commented-out.
   * One solution would be to make a PQ_operatorTemplate with an
   * OperatorName first argument... *)
  (*-> on:ConversionFunctionId "<" list:TemplateArgumentListOpt ">" *)
  (*	{ unimplemented 505 } *)


  (* version with the word "template" in front
   *
   * arg.. this causes some extra ambiguities, see t0255.cc.  since I
   * don't have a testcase that requires this yet, I'll just remove it *)
  (*-> "template" n:Identifier "<" list:TemplateArgumentListOpt ">" *)
  (*	{ unimplemented 506 } *)
}

nonterm TemplateArgumentList {
  fun merge(l,r) { ambiguous 1006 (Sexplib.Conv.sexp_of_list sexp_of_template_argument) (List.rev l) (List.rev r) }

  -> x:TemplateArgument
	[Head] { [x] }

  -> xs:TemplateArgumentList "," x:TemplateArgument
	[Tail] { x :: xs }
}

nonterm TemplateArgument {
  (* ambiguous due to type/variable name ambiguity, and also
   * due to angle brackets vs. less-than *)
  fun merge(l,r) { TA_ambig (l, r) }

  -> typeid:TypeId
	[Type] { TA_type (typeid) }

  -> e:AssignmentExpression
	[Expr] {
	  match Disambiguation.disambig_nontype_targ e with
	  | None ->
	    (* this is the wrong interpretation because template argument
	     * expressions aren't allowed to have unparenthesised
	     * greater-than operators [cppstd 14.1 para 15]
	     *
	     * this helps eliminate a nasty ambiguity in function
	     * declarators, as otherwise
	     *	 template <class T>
	     *	 Foo<T> & Foo<T>::get() {}
	     * could be interpreted as a constructor (we don't realise
	     * that 'get' != 'Foo') of a template class with template
	     * argument "T > &Foo < T" *)
	    cancel "template argument has unparenthesised greater-than operator"
	  | Some e ->
	    TA_nontype (e)
	}

  (* is this for template args that are templates, or what? *)
  (*-> IdExpression; *)
}

nonterm ExplicitInstantiation {
  -> "template" d:BlockDeclaration
	{ unimplemented 513 }
  -> "inline" "template" d:BlockDeclaration
	{ unimplemented 514 }
}

(* ------ A.13 Exception handling ------ *)
nonterm TryBlock {
  -> "try" s:CompoundStatement h:HandlerSeq  { unimplemented 515 }
}

nonterm HandlerSeq {
  -> h:Handler			{ unimplemented 516 }
  -> seq:HandlerSeq h:Handler	{ unimplemented 517 }
}

nonterm Handler {
  -> "catch" "(" d:HandlerParameter ")" s:CompoundStatement
	{ unimplemented 518 }

  -> "catch" "(" "..." ")" s:CompoundStatement
	{ unimplemented 519 }
}

nonterm HandlerParameter {
  -> s:TypeSpecifier d:UnqualifiedDeclarator
	{ unimplemented 520 }
  -> s:TypeSpecifier d:AbstractDeclaratorOpt
	{ unimplemented 521 }
}


(* this nonterminal helps with the TYPENAME ::NAME ambiguity, and also
 * partially enforces 8.3.5p8, which says that a parameter name must
 * be an identifier (only), if present *)
nonterm UnqualifiedDeclarator {
  fun keep(d) {
    let n = Query.id_of_declarator d in
    (* n is never None *)
    if Query.name_has_qualifiers (BatOption.get n) then
      (* qualified UnqualifiedDeclarator *)
      false
    else
      true
  }

  -> d:Declarator;
}

(* note: There is no such thing as an UnqualifiedAbstractDeclaratorOpt
 * because abstract declarators do not contain an id-expression. *)


nonterm ThrowExpression {
  -> "throw"				[ReThrow] { unimplemented 523 }
  -> "throw" e:AssignmentExpression	[Throw] { unimplemented 524 }
}


nonterm ExceptionSpecificationOpt {
  -> empty
	{ None }
  -> s:ExceptionSpecification
	{ Some s }
}

nonterm ExceptionSpecification {
  -> "throw" "(" ")"
	[NoThrow] { [] }
  -> "throw" "(" list:TypeIdList ")"
	[Throw] { list }
}

nonterm TypeIdList {
  -> t:TypeId
	{ [t] }
  -> list:TypeIdList "," t:TypeId
	{ t :: list }
}


(* ------------------------ namespaces ----------------------- *)
nonterm NamespaceDefinition {
  -> "namespace" n:IdentifierOpt "{" unit:TranslationUnit "}"
	[NamespaceDefn] { TF_namespaceDefn (n, unit) }
}

nonterm NamespaceDecl {
  -> "namespace" alias:Identifier "=" orig:IdExpression ";"
	[Alias] { ND_alias (alias, orig) }

  (* cppstd allows "typename" after "using", but doesn't specify what
   * it means; I assume they mean to use its semantics as described
   * elsewhere, but I don't feel like tracking that down now *)
  -> "using" (*typename?*) n:IdExpression ";"
	[UsingDecl] { ND_usingDecl (n) }

  -> "using" "namespace" n:IdExpression ";"
	[UsingDir] { ND_usingDir (n) }
}



(* ------------------------ annotations ----------------------- *)
nonterm AnnotationOpt {
  -> empty		{ None }
  -> a:AnnotationList	{ Some a }
}

nonterm AnnotationList {
  -> a:TOK_ANNOTATION
	{ unimplemented 536 }
  -> l:AnnotationList a:TOK_ANNOTATION
	{ unimplemented 537 }
}
