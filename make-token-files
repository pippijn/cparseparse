#!/usr/bin/perl -w
# see usage string below

use strict 'subs';

sub usage {
  print(<<"EOF");
usage: $0 [-o outname] file.tok [extension.tok [...]]

This script processes a master token description and produces several files:
  - a .ml file with the enumeration listing all the tokens
  - a .cc file with a table of spellings, and table of flags
  - a .ids file with grammar token names, ids, and aliases

The filenames are named with the same base as the input .tok file,
or with whatever base is specified with the -o option.
EOF
}

$baseName = "";
$myCommand = "$0 " . join(' ', @ARGV);

while (@ARGV != 0 && $ARGV[0] =~ m/^-/) {
  my $arg = $ARGV[0];
  shift @ARGV;
  if ($arg eq "-o") {
    $baseName = $ARGV[0];
    shift @ARGV;
  }
  else {
    print("unknown option: $arg\n");
    usage();
    exit(2);
  }
}

if (@ARGV < 1) {
  usage();
  exit(0);
}

$fname = $ARGV[0];

if (!$baseName) {
  $baseName = $fname;
  $baseName =~ s|\.[^.]*$||;    # strip extension
}

# open the output files
open(my $H, ">$baseName.ml") or die("cannot open $baseName.ml: $!\n");
open(my $CC, ">${baseName}_desc.ml") or die("cannot open ${baseName}_desc.ml: $!\n");
open(my $IDS, ">$baseName.ids") or die("cannot open $baseName.ids: $!\n");


# write the preambles

$latch = "$baseName.ml";
$latch =~ tr|a-z./|A-Z__|;
print $H (<<"EOF");
(* $baseName.ml
 * do not edit; this file automatically generated by
 *   $myCommand
 *)

(* token flags *)
type token_flag =
  | TF_MULTISPELL     (* token has multiple spellings *)
  | TF_NONSEPARATOR   (* token is a nonseparator *)
  | TF_CPLUSPLUS      (* token is a keyword in C++, but an identifier in C *)

type token_type =
EOF


print $CC (<<"EOF");
open Cc_tokens

let token_desc = function
EOF


# I'll have to accumulate the flags in a big list and then
# emit them after I close the 'tokenNames' array
@flagsList = ();


print $IDS (<<"EOF");
// $baseName.ids
// do not edit; this file automatically generated by
//   $myCommand

// form:
//   <code> : <name> [<alias>] ;

EOF


# process the input file(s), effectively a concatenation of all the
# files supplied on the command line
$nextId = 0;
while (@ARGV > 0) {
  $fname = $ARGV[0];
  $lineNum = 0;
  shift @ARGV;

  # open the input file
  open(my $IN, "<$fname") or die("cannot open $fname: $!\n");

  # process it
  while (defined($line = <$IN>)) {
    $lineNum++;

    # blank lines and comment lines are copied to the output verbatim,
    # once we've seen the first line which is neither
    if ($line =~ m|^\s*$| or
        $line =~ m|^\s*//|) {
      if (0 and $nextId) {
        # indent unindented comments
        if ($line =~ m|^//|) {
          $line = "  " . $line;
        }

        print $H ($line);
        push @flagsList, $line;
        print $IDS ($line);
      }
      next;
    }

    # parse the line
    chomp($line);
    my ($enumerator, $spelling, $flags) =
      ($line =~ m|^\s*([a-zA-Z_0-9]+),\s*(\"[^\"]*\")\s*,\s*:(.*)$|);

    #print("enumerator: $enumerator\n");
    #print("spelling:   $spelling\n");
    #print("flags:      $flags\n");
    #exit(0);

    if (!defined($flags)) {
      die("$fname:$lineNum: malformed line\n");
    }

    # parse the flags
    $multiSpell = ($flags =~ m|m|);
    $nonsep = ($flags =~ m|n|);
    $cpp = ($flags =~ m|p|);

    # emit to each file
    print $H  ("  | $enumerator\n");
    print $CC ("  | $enumerator -> \"$enumerator\"\n");

    my @f = ("0");
    if ($multiSpell) { push @f, "TF_MULTISPELL"; }
    if ($nonsep)     { push @f, "TF_NONSEPARATOR"; }
    if ($cpp)        { push @f, "TF_CPLUSPLUS"; }
    push @flagsList, sprintf("  %-40s // $enumerator\n",
                             join(' | ', @f) . ",");

    printf $IDS ("  %3d : %-30s %s;\n",
                $nextId,
                $enumerator,
                ($multiSpell? "" : $spelling));

    $nextId++;
  }
}
