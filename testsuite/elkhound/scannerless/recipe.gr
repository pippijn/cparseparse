// sless.gr
// example of scannerless operation in Elkhound

terminals {
    0: CHAR_EOF;
   10: CHAR_NEWLINE;
   32: CHAR_SPACE;
   40: CHAR_LPAREN       "(";
   41: CHAR_RPAREN       ")";
   97: A                 "a";
   98: B                 "b";
   99: C                 "c";
  100: D                 "d";
  101: E                 "e";
  102: F                 "f";
  103: G                 "g";
  104: H                 "h";
  105: I                 "i";
  106: J                 "j";
  107: K                 "k";
  108: L                 "l";
  109: M                 "m";
  110: N                 "n";
  111: O                 "o";
  112: P                 "p";
  113: Q                 "q";
  114: R                 "r";
  115: S                 "s";
  116: T                 "t";
  117: U                 "u";
  118: V                 "v";
  119: W                 "w";
  120: X                 "x";
  121: Y                 "y";
  122: Z                 "z";
}

nonterm(unit) Start {
  -> WS p:Prog { }
}

nonterm Prog {
  -> empty { }
  -> p:Prog id:IDENT [Ident] { }
  -> p:Prog IF cond:Prog FI [If] { }
  -> p:Prog LPAREN e:Prog RPAREN [Expr] { }
}

nonterm Ident {
  fun maximal() {}          // use maximal munch disambiguation
  //-> "a" { }
  //-> "b" { }
  //-> "c" { }
  //-> "d" { }
  //-> "e" { }
  -> "f" { }
  //-> "g" { }
  //-> "h" { }
  -> "i" { }
  //-> "j" { }
  //-> "k" { }
  //-> "l" { }
  //-> "m" { }
  //-> "n" { }
  //-> "o" { }
  //-> "p" { }
  //-> "q" { }
  //-> "r" { }
  //-> "s" { }
  //-> "t" { }
  //-> "u" { }
  //-> "v" { }
  //-> "w" { }
  //-> "x" { }
  //-> "y" { }
  //-> "f" { }

  //-> "a" Ident { }
  //-> "b" Ident { }
  //-> "c" Ident { }
  //-> "d" Ident { }
  //-> "e" Ident { }
  -> "f" Ident { }
  //-> "g" Ident { }
  //-> "h" Ident { }
  -> "i" Ident { }
  //-> "j" Ident { }
  //-> "k" Ident { }
  //-> "l" Ident { }
  //-> "m" Ident { }
  //-> "n" Ident { }
  //-> "o" Ident { }
  //-> "p" Ident { }
  //-> "q" Ident { }
  //-> "r" Ident { }
  //-> "s" Ident { }
  //-> "t" Ident { }
  //-> "u" Ident { }
  //-> "v" Ident { }
  //-> "w" Ident { }
  //-> "x" Ident { }
  //-> "y" Ident { }
  //-> "f" Ident { }

  subsets If, Fi;           // prefer keywords to identifiers
}

// keywords
nonterm If -> "i" "f" { }
nonterm Fi -> "f" "i" { }

// tokens, with whitespace following
nonterm IDENT -> Ident WS { }
nonterm IF -> If WS { }
nonterm FI -> Fi WS { }
nonterm LPAREN -> "(" WS { }
nonterm RPAREN -> ")" WS { }

// whitespace
nonterm WS {
  -> empty { }
  -> CHAR_SPACE WS { }
  -> CHAR_NEWLINE WS { }
}
